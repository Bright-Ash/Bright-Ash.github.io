--- 
title: "Spring | Spring" 
date: 2024-12-12 13:30:00 +0900
achieved: 2024-12-13 17:30:00 +0900
math: true
categories: [Bootcamp, KT Aivle School]
tags: [Bootcamp, KT Aivle School, Spring]
---
---------- 	
> Spring 기초 정리 글입니다. 
{: .prompt-info } 


## **Chap 1. 웹 프로그래밍의 이해**

***

---

### **웹(Web)**

#### **웹(Web)이란?**
- 1989년 팀 버너스리가 여러 연구 기관에 흩어져 있는 문서와 정보를 체계화하고 공유하기 위해 연구한 개념
- **HTTP 프로토콜**과 **TCP/IP 네트워크**를 기반으로 **HTML**로 작성된 하이퍼텍스트를 포함한 콘텐츠를 제공하는 서비스

##### **HTML과 하이퍼텍스트**
- **HTML (Hyper Text Markup Language)**: 웹 페이지의 구조를 정의하는 언어로, 브라우저가 내용을 해석하고 표현함
- **하이퍼텍스트 (HyperText)**: 링크를 통해 다른 웹 페이지로 이동할 수 있도록 하는 텍스트

> **HTML**은 웹 페이지의 뼈대를 만들고, 하이퍼텍스트는 페이지 간의 연결을 만들어주는 핵심 개념

#### **프로토콜 (Protocol)**
- **프로토콜 (Protocol)**: 네트워크에 연결된 컴퓨터 간의 통신 규칙
- 웹에서는 브라우저의 요청과 서버의 응답을 주고받기 위해 **HTTP 프로토콜**을 사용함

#### **HTTP (Hyper Text Transfer Protocol)**
- **HTTP**는 **클라이언트(브라우저)**와 **서버** 간의 데이터 교환을 위한 **텍스트 기반의 통신 규약**
- **TCP/IP** 프로토콜을 기반으로 하며, **기본 포트는 80번**임
- 클라이언트는 서버의 **IP와 포트 번호**를 알고 있어야 하며, 이를 바탕으로 통신을 수행함

##### **요청(Request)과 응답(Response)**
- 사용자가 브라우저에서 특정 URL을 호출하면 "요청(Request)과 응답(Response)"이 하나의 쌍으로 처리됨
- 요청-응답이 완료되면 **연결이 끊어지는 비연결성**의 특징이 있음
- 클라이언트를 식별하기 위해 **쿠키(Cookie)**와 **세션(Session)**이 사용됨

##### **주요 HTTP 메서드**
| **Method** | **설명** |
|------------|----------|
| **POST**  | 서버에 데이터를 추가로 전송할 때 사용 |
| **GET**   | 특정 리소스를 조회할 때 사용 |
| **PUT**   | 기존 리소스를 대체할 때 사용 (리소스가 없으면 새로 생성) |
| **PATCH** | 리소스의 일부만 수정할 때 사용 |
| **DELETE**| 리소스를 삭제할 때 사용 |

##### **HTTP 상태 코드 (Status Code)**
- **HTTP 상태 코드**는 특정 HTTP 요청의 성공 또는 실패 상태를 나타내는 숫자 코드

###### **1. 2xx (Success) - 요청 성공**
| **코드** | **설명** |
|----------|----------|
| **200 OK** | 요청이 성공적으로 처리됨 |
| **201 Created** | 요청 성공으로 새로운 리소스가 생성됨 |
| **202 Accepted** | 요청이 수신되었으나 아직 처리되지 않음 |
| **204 No Content** | 요청이 성공했지만 반환할 콘텐츠가 없음 |

###### **2. 3xx (Redirection) - 리다이렉션**
- 추가 작업이 필요함을 나타냄 (ex. 페이지 이동)

###### **3. 4xx (Client Error) - 클라이언트 요청 오류**
| **코드** | **설명** |
|----------|----------|
| **400 Bad Request** | 잘못된 요청으로 서버가 이해할 수 없음 |
| **401 Unauthorized** | 인증이 필요함 |
| **403 Forbidden** | 접근 권한이 없음 |
| **404 Not Found** | 요청한 리소스를 찾을 수 없음 |
| **405 Method Not Allowed** | 허용되지 않는 메서드 요청 |
| **409 Conflict** | 요청이 서버 상태와 충돌 발생 |

###### **4. 5xx (Server Error) - 서버 오류**
| **코드** | **설명** |
|----------|----------|
| **500 Internal Server Error** | 서버에 오류가 발생하여 요청을 처리할 수 없음 |
| **503 Service Unavailable** | 서버가 요청을 처리할 준비가 되어 있지 않음 |

---

### **TCP/IP 개념**

#### **TCP (Transmission Control Protocol)**
- 두 개의 호스트 간에 연결을 생성하고 데이터 스트림을 교환하는 **네트워크 프로토콜**
- **전송 순서 보장**: 보낸 순서대로 데이터를 전달함

#### **TCP/IP 네트워크 계층**
1. **애플리케이션 계층 (Application Layer)**
    - 사용자가 네트워크에 접근할 수 있는 인터페이스 제공
    - 이메일, 파일 전송, 데이터베이스 관리 등의 서비스를 제공함

2. **전송 계층 (Transport Layer)**
    - 데이터의 전송을 담당하는 계층으로, **TCP와 UDP**가 존재함

3. **인터넷 계층 (Internet Layer)**
    - 데이터 패킷의 전송을 관리하며, 목적지까지 데이터를 효율적으로 전달함

4. **네트워크 액세스 계층 (Network Access Layer)**
    - 물리적 네트워크를 통해 데이터를 전송하는 계층
    - 데이터를 전기 신호로 변환하여 MAC 주소를 통해 전달함

#### **IP (Internet Protocol)**
- 데이터를 목적지까지 전송하는 역할을 담당함
- TCP/IP 네트워크에서 각각의 컴퓨터를 구분하기 위해 사용하는 주소 체계

#### **TCP/IP의 특징**
- 하드웨어, 운영체제, 네트워크 매체에 **독립적으로 동작**하는 개방형 구조
- **TCP**: 데이터의 흐름을 관리하고 전송 오류를 확인함
- **IP**: 데이터를 목적지까지 전달하는 역할을 수행함

#### **포트 (Port)**
- **IP 주소 내에서 애플리케이션의 프로세스를 구분**하기 위한 번호
- 예시: 
  - **80번 포트**: HTTP (웹)
  - **443번 포트**: HTTPS (보안 웹 통신)

#### **DNS (Domain Name Server)**
- 사용자가 입력한 **도메인 이름을 IP 주소로 변환**하는 시스템
- 클라이언트가 URL 주소를 입력하면, DNS 서버는 해당 URL에 매핑된 **IP 주소를 반환**함

#### **웹의 동작 구조**
1. 웹 브라우저에서 도메인을 입력한다.
2. DNS 서버는 해당 도메인을 가진 IP 주소를 웹 브라우저에게 전송한다.
3. 웹 브라우저는 IP 주소의 해당 서버에 접속을 시도한다. 웹 서버는 접속을 기다리다 접속 요청이 들어오면 수락한다.
4. 웹 서버는 요청 내용을 분석하고 요청된 [index.html] 파일을 읽는다.
5. 웹 서버는 파일 내용을 클라이언트에 전송한다.
6. 웹 브라우저는 웹 서버로부터 받은 내용을 이용하여 HTML 태그를 분석해 화면을 구성한다.

##### **초창기의 웹 렌더링**
- 모든 웹 페이지가 정적인 페이지로 구성됨.
- 웹 브라우저가 서버에 **HTTP 요청**을 전송하고, 서버는 **HTML 파일**을 전달함.
- 화면에 변화를 주려면, 서버에 **새로운 요청을 보내고 HTML을 다시 전송** 받아야 했음.

##### **Ajax의 등장으로**
- **Ajax**는 자바스크립트를 통해 서버와 브라우저가 **비동기 통신**을 하며 데이터를 주고받을 수 있게 함.
> **비동기 통신**: 서버와의 통신 중에도 다른 작업을 동시에 수행할 수 있는 통신 방식.
- 예) 댓글을 작성하고 등록했을 때, 페이지 전체가 새로 고침되지 않고 댓글 부분만 업데이트됨.
- 필요한 부분의 데이터만 불러와 **화면을 동적으로 변경**할 수 있게 되었음.
- 서버에서 이루어지던 다양한 로직 처리를 클라이언트에서도 일부 처리 가능해짐.
> **렌더링**: HTML, CSS, JavaScript 파일을 파싱하여 화면에 표시하는 과정.

#### **CSR (Client Side Rendering)**
![image](https://github.com/user-attachments/assets/11e931d5-43b3-4046-b35b-3988a3fd67b7)
- 클라이언트(브라우저)가 렌더링을 처리하는 방식으로, 서버에서 받은 데이터를 통해 클라이언트인 브라우저가 화면(View)을 그리는 주체가 됨.

![image](https://github.com/user-attachments/assets/dd31061c-d862-48b9-b569-26cb490e1ac3)
1. 클라이언트가 웹 사이트 요청을 보냄.
2. CDN이 HTML 파일과 자바스크립트로 접근할 수 있는 링크를 클라이언트에게 전송한다.
3. 클라이언트는 HTML과 자바스크립트를 다운로드 받는다.
4. 다운로드가 완료된 HTML과 자바스크립트가 웹 브라우저에서 실행된다.
5. API로부터 받아온 데이터를 넣어주면 페이지 상호작용이 가능해진다.

#### **SSR (Server Side Rendering)**
![image](https://github.com/user-attachments/assets/9c5d0d8c-c898-4b1c-914b-f0cd54fff2f8)
- 서버 쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달하는 방식.

![image](https://github.com/user-attachments/assets/64c5950a-cca3-41b1-adfa-b47277f96138)
1. 클라이언트가 웹 사이트 요청을 보냄.
2. 서버는 즉시 렌더링이 가능한 HTML 파일을 만들어 클라이언트에 전달한다.
3. 클라이언트에 전달되는 순간 HTML은 즉시 렌더링 되어 화면을 표시한다.
4. 클라이언트가 자바스크립트를 다운받는다.
5. 브라우저가 자바스크립트 프레임워크를 실행한다.
6. 자바스크립트가 성공적으로 컴파일되면 웹 페이지의 상호작용이 가능해진다.

---

### **클라이언트와 서버**

#### **웹 프로젝트의 기본 구조**
##### **3-Tier Architecture (3계층 구조)**
![image](https://github.com/user-attachments/assets/ebdf619d-ac40-4c11-96d3-badc1ad2757d)
- 애플리케이션을 **프레젠테이션 계층, 애플리케이션 계층, 데이터 계층**으로 나눈 소프트웨어 아키텍처.
- 각 계층이 자체 인프라에서 실행되어 동시에 개발될 수 있으며, 서로 다른 계층에 영향을 주지 않고 필요에 따라 업데이트 하거나 수정할 수 있음. (독립성 증가)

#### **프리젠테이션 계층 (클라이언트)**
- 서버에서 응답(Response) 받은 결과를 화면에 렌더링하여 사용자에게 보여주고 서버에 원하는 데이터를 요청(Request) 하는 프로그램.
- 해당 계층은 front-end 라고도 불린다.
> **사용 기술**: HTML, CSS, JavaScript 등

#### **애플리케이션 계층 (서버)**
- 클라이언트에게 서비스를 제공하는 시스템으로, 클라이언트의 요청(Request)에 데이터를 가공하여 응답(Response)하는 시스템.
- 해당 계층은 미들웨어 또는 back-end로 불린다.
> **사용 기술**: Spring, PHP 등

#### **데이터 계층 (데이터베이스)**
- 애플리케이션에서 사용되는 데이터를 **영구적으로 저장하고 관리**하는 부분.
- 데이터베이스에 접근하여 데이터를 읽거나 쓰는 것을 관리하는 계층.
> **사용 기술**: MySQL, Oracle, MongoDB 등

#### **데이터베이스 (DataBase)**
- 데이터 계층 또는 데이터베이스는 애플리케이션에서 사용되는 데이터를 **영구적으로 저장하고 관리**하는 부분.
- 데이터베이스 관리 시스템(DBMS)을 사용하여 구현된다.
  - 주요 데이터베이스 관리 시스템으로는 MySQL, Oracle, PostgreSQL, MongoDB 등이 있으며, 각각의 데이터베이스는 특정 용도나 성능, 확장성 등을 고려하여 선택될 수 있다.
- 데이터베이스는 다양한 형태의 데이터를 구조화 하여 저장하고, 필요에 따라 검색, 수정, 삭제, 추가 등의 작업을 수행할 수 있다.
  - 일반적으로 데이터베이스는 테이블(Table)이라는 구조로 데이터를 저장하며, 각 테이블은 여러 개의 열(Column)로 구성되어 있다.
- 데이터베이스는 관계형 데이터베이스(RDBMS)와 NoSQL 데이터베이스로 구분될 수 있다.
  - 관계형 데이터베이스는 테이블 간의 관계를 중심으로 데이터를 저장하고 관리하는 반면, NoSQL 데이터베이스는 유연한 데이터 모델을 제공하여 비정형 데이터나 대규모 데이터를 다룰 때 유용하다.
- 데이터 계층은 애플리케이션과 데이터베이스 간의 상호작용을 관리하며, 데이터베이스에 저장된 데이터를 검색, 수정, 삭제, 추가 등의 CRUD 작업을 수행하여 애플리케이션의 요구에 따라 필요한 정보를 제공한다.

---

## **Chap 2. Spring Framework**

***

---

### **Framework란?** 

#### **Framework**
> “프레임워크란, 소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게끔 일련의 협업화 된 형태로 클래스들을 제공하는 것” - Ralph Johnson.
- 프레임워크는 애플리케이션 개발 시 필수적인 코드, 알고리즘 등의 기능들을 위해 뼈대를 제공한다.
- 개발자는 이런 뼈대 위에서 코드를 작성하여 애플리케이션을 개발할 수 있다.
> 예) Spring MVC 웹 프레임워크는MVC 디자인 패턴이라는 정량화 된 구조 안에서 웹 서버를 어떤 구조로 만들면 되는지 방향을 제시해준다.

#### **Library**
> “라이브러리란 주로 소프트웨어를 개발할 때 필요한 기능(함수)들을 모아 놓은 소프트웨어”
> ”특정 작업을 수행하는 기능이나 메소드의 모음”
- 라이브러리는 개발자가 개발하는 데 필요한 것들을 모아 둔 도구들의 나열로, 개발자가 필요로 할 때 호출하여 사용하는 방식을 취하고 있다.
> 예) Python NumPy ⇒ 파이썬의 수치 계산 라이브러리


#### **Framework와 Library의 차이점**
- Framework는 제어의 역전(IoC) 개념이 적용되어 있다.
  - 제어의 역전을 쉽게 생각하면 ⇒ 객체를 개발자가 관리하지 않고 프레임워크가 관리한다. 
  - 객체의 생성과 소멸을 프레임워크가 관리한다.
- 라이브러리는 개발자가 전체적인 사용 흐름을 만든다.
  - 개발자는 필요할 때 마다 능동적으로 라이브러리를 호출하여 사용한다.


#### **클래스의 인스턴스를 생성하여 의존성 주입**
> **의존성(Dependency)**: 한 객체의 코드에서 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 의존성이 발생한다고 할 수 있다.

```java
public class MemberService {
    private MemberRepository memberRepository = new MemberRepository();

    public void createMember(String email) {
                Member member = new Member(email);
                memberRepository.save(member);
    }
}
```
- 일반적으로 개발자가 MemberService에서 new를 이용하여 MemberRepository의 인스턴스를 생성하여 의존성을 주입하고 있는 예시 코드이다.
- 생성한 memberRepository 인스턴스를 createMember() 메소드에서 사용하고 있다.

#### **생성자 주입을 통한 의존성 주입**
```java
@Service
public class MemberService {
    private final MemberRepository memberRepository;
    
    @Autowired
    public MemberService(MemberRepository memberRepository) {
                this.memberRepository = memberRepository;
    }

    public void createMember(String email) {
            Member member = new Member(email);
            memberRepository.save(member);
    }
}
```
- Spring 프레임워크는 @Autowired 어노테이션을 통해 MemberService에서 MemberRepository의 의존성을 외부에서 주입해준다.
  - 해당 코드에서 new 연산자를 사용하여 인스턴스를 생성하지 않았음에도 memberRepository를 createMember() 메소드에서 사용하고 있다.
  - 이는 스프링 컨테이너가 객체의 생명 주기(객체의 생성과 소멸)을 관리 하고 있기 때문이다. 즉, 제어의 역전이 적용 된 예시라고 생각하면 된다.

---

### **Spring Framework란?**  

#### **Spring 생태계 살펴보기**
- **핵심 기술** : 스프링 IoC 컨테이너 , AOP , 기타 등등
- **웹 기술** : 스프링 MVC , 스프링WebFlux
- **데이터 접근 기술** : 트랜잭션, JDBC , ORM
- **테스트** : 스프링 기반 테스트 지원 등등…

#### **Spring Framework**
> Java 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크로써 엔터프라이즈급 애플리케이션을 개발하기 위한 모든 기능을 종합적으로 제공하는 경량화 된 솔루션
- Spring의 핵심
  - 스프링은 Java 언어 기반의 프레임워크.
  - Java 언어의 가장 큰 특징은 “객체 지향 언어”
  - → 즉, 스프링은 객체 지향 언어가 가진 가장 강력한 특징을 살려내면서 애플리케이션 제작이 가능하게 해준다.
  - SOLID 원칙에 부합하는 프로그래밍이 가능하며, 확장성이 높다.

#### **Spring Framework의 특징**
1. **POJO(Plain Old Java Object) 기반의 구성**
> **POJO(Plain Old Java Object)**: 객체 지향적인 원리에 충실하면서 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오프젝트트
- 단순히 순수 자바 객체만을 사용해서 프로그래밍 코드를 작성한다.
- 즉, **“Java나 Java의 사양에 정의된 것 의외에는 다른 기술이나 규약에 얽매이지 않아야 한다.”**
2. **제어의 역행(IoC)과 의존성 주입(DI)을 통한 객체 간의 구성**
- **제어의 역행(Inversion Of Control)**
  - 코드의 최종 호출을 개발자가 하는 것이 아닌, 스프링 프레임워크 내부에서 이루어진다.
  - 즉, 코드 제어의 흐름이 프레임워크에 종속되어 있다.
  - 간단히 말하자면, 지금까지는 사용자가 new 연산을 통해 객체를 생성하고 메소드를 호출했다.
  - 제어의 역행이 적용된 경우 사용자는 new를 이용해 생성된 객체를 사용하지 않고, 스프링에 의해 관리 당하는 (주입되는)자바 객체를 사용한다.


- **의존성 주입 (Dependency Injection)**
> **의존성**: 한 객체의 코드에서 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 의존성이 발생한다고 할 수 있다.
  - MemberController 클래스가 MemberService의 getMemberList() 메서드를 사용할 때, MemberController는 MemberService에 의존한다고 할 수 있다.
  - Spring 기반의 애플리케이션에서는 애플리케이션 코드에서 이루어지는 의존성 주입을 Spring이 대신 해주며, 클래스들 간의 결합을 느슨한 결합으로 만들어 주어 유연성을 높여준다.


3. **경량 컨테이너**
> 스트링 프레임워크를 개발자를 대신하여 **Bean(객체)을 생성 및 관리하는 컨테이너**를 갖고 있으며, 이를 **스프링 컨테이너**라고 부른다.
- **스프링 컨테이너(Spring Container)** : 스프링에서 자바 객체들을 관리하는 공간
- **빈(Bean)** : 스프링 컨테이너가 관리하는 자바 객체
  - 스프링 컨테이너는 빈(Bean)의 생성부터 소멸까지 개발자 대신 관리해준다.
  - 스프링 컨테이너에 객체, 빈(Bean)을 등록하는 이유는 객체간의 의존 관계들을 스프링이 관리하도록 하기 위해서다.


4. **AOP(관점 지향 프로그래밍) 지원**
> **Spring AOP(Aspect-oriented-programming)**: 스프링 프레임워크에서 제공하는 기능 중 하나로 **관점 지향 프로그래밍**을 지원하는 기술이다.
- Spring AOP는 로깅, 보안, 트랜잭션 등과 같은 공통적인 관심사를 모듈화 하여 코드 중복을 줄이고, 유지 보수성을 향상시키는 데 도움을 준다.
![image](https://github.com/user-attachments/assets/cc7f520b-0b69-4b67-b334-89dc2a70637d)
![image](https://github.com/user-attachments/assets/67137923-a27b-4759-ae09-a8b09e2e30ad)
- **“여러 개의 클래스에서 반복해서 사용하는 코드가 있다면”** ⇒ 해당 코드를 모듈화 하여 공통 관심사로 분리
- **공통 로직을 Aspect로 모듈화 하고 핵심적인 비즈니스 로직에서 분리하여 재사용하겠다는 것이 AOP의 취지이다.**

---

### **OOP + POJO**  

#### **POJO(Plain Old Java Object)**
![image](https://github.com/user-attachments/assets/88b61b37-5e2b-401c-a907-300dba9ae525)
- Spring은 POJO를 지향하는 프레임워크다.
- 앞에서 살펴본 바와 같이, 특정 기술에 종속되어 작동하는 것이 아닌 순수한 자바 객체를 의미한다.
- 위의 사진은 Spring 삼각형이라는 그림이며, POJO는 IoC/DI , AOP , PSA를 통해서 달성할 수 있다는 것을 의미한다.

##### **왜 Spring은 POJO를 지향하는가?**
- 특정 기술들에 종속성을 띄우게 되면, 객체지향적인 설계가 힘들거나 불가능한 경우가 발생한다.
- 위와 같은 문제는 코드의 유지보수와 재사용성에서 매우 불리해진다.
> POJO는 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용 될 수 있는 방식으로 설계되는 장점을 갖고 있다.

#### **객체 지향 프로그래밍 (Object-Oriented Programming)**
##### **절차 지향 프로그래밍과 객체 지향 프로그래밍**
###### **절차 지향 프로그래밍
> 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시되면 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법법
- 대표적 예) C언어
- 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체 지향 언어를 사용하는 것에 비해 더 빨리 처리된다.
###### **객체 지향 프로그래밍**
> 프로그램을 객체라는 최소 단위로 나누고, **객체의 유기적인 상호작용**을 통해 로직을 구성하는 프로그래밍 방법

##### **객체 지향 프로그래밍(OOP)의 특징**
1. **캡슐화** : **낮은 결합도를 유지할 수 있도록 설계하는 것**
- 객체의 내부 구현을 감춤(은닉)으로써, 한 곳에서 변화가 일어나더라도 다른 곳에 미치는 영향을 최소화 하는 것
- 은닉 : 구현은 숨기고 동작은 노출시킴
> **접근 제어자** : 자바가 캡슐화를 수행할 때 쓰는 핵심 수단으로, private , default , protected , public 총 4가지가 있다.
|접근 제어자|같은 클래스의 맴버|같은 패키지의 멤버|자식 클래스의 멤버|전체|
|----------|----------|----------|----------|----------|
|public|O|O|O|O|
|protected|O|O|O| |
|default|O|O| | |
|private|O| | | |
2. **상속** : **자식 클래스에서 부모 클래스로부터 자원을 물려받는 것**
- 상속을 사용하게 될 경우 개발자들은 코드의 중복성을 최소화 할 수 있다.
- 자식이 부모의 기능과 속성을 중복해서 가져가야 할 때는 상속을 통해 물려받고, 추가적으로 필요한 기능만 추가할 수 있다.
```java
class Animal {
    void makeSound() {
        System.out.println("Some generic sound");
    }
    void reproduce() {
        System.out.println("The animal reproduces");
    }
}
class Cat extends Animal {
    void scratch() {
        System.out.println("Cat scratches");
    }
    void jump() {
        System.out.println("Cat jumps");
    }
}
class Dog extends Animal {
    void dig() {
        System.out.println("Dog digs");
    }
    void run() {
        System.out.println("Dog runs");
    }
}
```
3. **다형성 : 한 객체가 다른 여러 형태(객체)로 재구성될 수 있다.**
- 자바의 Overload , Override가 다형성의 대표적인 예
- Overload는 하나의 클래스 안에 같은 이름의 메소드를 여러 개 지닐 수 있는 것
- Override는 상속받은 메소드를 재정의하여기능을 확장해 코드 중복성을 줄이는 것

```java
class Animal {
    void makeSound() {
        System.out.println("Some generic sound");
    }
    void reproduce() {
        System.out.println("The animal reproduces");
    }
}
class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow");
    }
}
class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark");
    }
}
```
4. **추상화 : 공통의 속성이나 기능을 묶어 이름을 붙이는 것**
- 공통적인 부분만 파악해 추출하고, 필요하지 않은 세부 사항들은 제거한다.
- 즉, 객체의 공통적인 속성과 기능을 추출하여 정의하는 것
![image](https://github.com/user-attachments/assets/98281514-b3a9-44b7-977e-de2e76f5caed)
```java
abstract class Vehicle {
    protected int capacity;
    protected int speed;
    
    Vehicle(int capacity) {
        this.capacity = capacity;
        this.speed = 0;
    }
    abstract void move();
    abstract void stop();
    
    void displayInfo() {
        System.out.println("Capacity: " + capacity + ", Speed: " + speed);
    }
}
class Sedan extends Vehicle {
    Sedan() {
        super(5);
    }

    @Override
    void move() {
        speed = 60;
        System.out.println("Sedan moves at " + speed + " km/h");
    }

    @Override
    void stop() {
        speed = 0;
        System.out.println("Sedan stops");
    }
}

class Truck extends Vehicle {
    Truck() {
        super(2);
    }
    
    @Override
    void move() {
        speed = 45;
        System.out.println("Truck moves at " + speed + " km/h");
    }
    
    @Override
    void stop() {
        speed = 0;
        System.out.println("Truck stops");
    }
}
class Bus extends Vehicle {
    Bus() {
        super(40);
    }
    @Override
    void move() {
        speed = 50;
        System.out.println("Bus moves at " + speed + " km/h");
    }
    @Override
    void stop() {
        speed = 0;
        System.out.println("Bus stops");
    }
}
```

#### **객체 지향 설계 원칙(SOLID)**
##### **SRP : 단일 책임의 원칙 (Single Responsibility Principle)**
- 클래스는 단 한개의 책임(기능)을 가져야 한다는 원칙
- 한 클래스가 수행할 수 있는 기능(책임)이 여러 개라면, 클래스 내부의 메서드끼리 강한 결합을 갖게 될 가능성이 커지게 된다.
- **객체 지향 설계의 핵심은 응집도는 높게, 결합도는 낮게 프로그램**을 설계하는 것. 이에 책임(기능)을 잘게 쪼개어 분리시킬 필요가 있다
```java
public class Order {
    public void orderProcess() {
    // order logic . . .
    }
    public void payProcess() {
    // pay logic . . .
    }
}
```
- Order 클래스는 주문 프로세스와 결제 프로세스, 두 가지 책임(기능)을 담당하고 있다.
- 결제 프로세스의 로직이 변경될 시, 주문 프로세스의 로직 또한 변경 될 가능성이 있으므로 결합도가 높다
- 주문 프로세스와 결제 프로세스를 Order 클래스와 Payments 클래스로 나누어 처리하고 있다.
- 즉, 각각의 클래스는 한 가지 책임(기능)만을 담당하고 있다.
- 코드의 가독성과 유지보수성이 높아지고, 재사용성과 확장성이 늘어나는 장점을 갖게 되었다.

##### **OCP : 개방 - 폐쇄 원칙 (Open-Closed Principle)**
- 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 함.
- 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야 한다.
- OCP는 **추상화**와 **상속** 등을 통해 구현해 낼 수 있다.
- **자주 변화하는 부분을 추상화**하여, **기존의 코드를 수정하지 않고도 기능을 확장시킬 수 있게 설계**하여 **유연성과 재사용성, 유지보수성**을 높이는 것이 핵심
- Payments 인터페이스를 구현하여 새로운 결제 로직을 추가할 수 있습니다.
- 기존의 Payments 인터페이스를 수정하지 않고 (변경에는 닫혀 있고) , 인터페이스를 구현해 새로운 결제 수단을 추가 (확장에는 열려 있는) 할 수 있는 유연한 코드를 만들 수 있다.
---
```java
public interface Payments {
    void pay(int amount);
    }
@Component
public class SamsungPay implements Payments {
    @Override
    public void pay(int amount) {
        // 삼성페이 결제 로직 구현
        System.out.println("Samsung Pay: 결제 금액 " + amount + "원을 결제합니다.");
        // 추가 인증 로직...
    }
}
@Component
public class ApplePay implements Payments {
    @Override
    public void pay(int amount) {
        // 애플페이 결제 로직 구현
        System.out.println("Apple Pay: 결제 금액 " + amount + "원을 결제합니다.");
    }
}
```
##### **LSP : 리스코프 치환 원칙 (Liskov Substitution Principle)**
- 부모 객체와 자식 객체가 존재할 때, 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙.
- 즉, 상속이 일어나면 하위 타입인 자식 객체는 상위 타입인 부모 객체의 특성을 가지며, 이를 바탕으로 확장시켜 나갈 수 있음을 의미한다.
```java
public class Rectangle{
    protected int width;
    protected int height;

    public int getWidth() {
        return width;
    }
    
    public int getHeight() {
        return height;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public int calcArea(int width, int height) {
        int area = width height;
        return area;
    }
}
public class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        super.setWidth(width);
        super.setHeight(getWidth());
    }
    @Override
    public void setHeight(int height) {
        super.setHeight(height);
        super.setWidth(getHeight());
    }
}
public class LspTest{
    public static void main(String[] args){
        Rectangle rect = new Rectangle();
        rect.setWidth(3);
        rect.setHeight(5);

        System.out.println(rect.calcArea());

        Rectangle square = new Square();
        square.setWidth(3);
        square.setHeight(5);
        System.out.println(square.calcArea());
    }
}
```
- 리스코프 치환 원칙에 따라 자식 객체는 부모 객체를 완전히 대체할 수 있어야 한다.
- 직사각형의 넓이는 15이며, 정사각형으로 대체하여 넓이를 구하면 결과는 15여야 한다.
- 정사각형 넓이 결과는 25로 리스코프 치환 원칙에 위배된다.
```java
public class Shape {
    protected int width;
    protected int height;
    
    public int getWidth() {
        return width;
    }
    
    public void setWidth(int width) {
        this.width = width;
    }

    public int getHeight() {
        return height;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public void calcArea(int width, int height) {
        int area = width height;
        return area;
    }

    public class Rectangle extends Shape {
        public Rectangle(int width, int height) {
            setWidth(width);
            setHeight(height);
            System.out.println(calcArea(width,height));
        }
    }

    public class Square extends Shape {
        public Square(int length) {
            setWidth(length);
            setHeight(length);
            System.out.println(calcArea(width,height));
        }
    }
}
```
- 이제 더 이상 Rectangle과 Square가 상속 관계가 아니므로, 리스코프 치환 원칙의 영향에서 벗어났다.

##### **ISP : 인터페이스 분리 원칙 (Interface Segregation Principle)**
- 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야 한다.
- 만약 인터페이스의 추상 메서드들을 범용적으로 구현한다면, 그 인터페이스를 상속받은 클래스는 자신이 사용하지않는 인터페이스라도 억지로 구현해야 하는 상황이 찾아올 수 있다.
- 즉, 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하기 위해 인터페이스를 잘게 분리하는 것
```java
interface Multimedia {
    void play();
    void pause();
    void record();
    void stop();
}
class MediaPlayer implements Multimedia {
    public void play() {
        System.out.println("Media is playing");
    }
    public void pause() {
        System.out.println("Media is paused");
    }
    public void record() {
        throw new UnsupportedOperationException("Recording not supported");
    }
    public void stop() {
    System.out.println("Media is stopped");
    }
}
```
- MediaPlayer는 녹음 기능을 사용하지 않지만, 인터페이스로 인해 구현해야 한다.
- MediaPlayer는 정지 기능을 사용하지만, 녹음과 관련된 정지와 혼동될 수 있다.
```java
class SoundRecorder implements Multimedia {
    public void play() {
        throw new UnsupportedOperationException("Play not supported");
    }
    
    public void pause() {
        throw new UnsupportedOperationException("Pause not supported");
    }
    
    public void record() {
        System.out.println("Recording audio");
    }
    
    public void stop() {
        System.out.println("Recording is stopped");
    }
}
```
- SoundRecorder는 재생 기능을 사용하지 않지만, 인터페이스로 인해 구현해야 한다.
- SoundRecorder는 일시 정지 기능을 사용하지 않지만, 인터페이스로 인해 구현해야 한다.
```java
// 멀티미디어 기기를 플레이어와 녹음기로 기능을 나눠보자
interface Playable {
    void play();
    void pause();
}
interface Recordable {
    void record();
    void stop();
}
```
```java
// 불필요한 기능이었던 record가 사라지고 모호했던 stop 기능도 제거되었다.
class MediaPlayer implements Playable {
    public void play() {
        System.out.println("Media is playing");
    }
    public void pause() {
        System.out.println("Media is paused");
    }
}
```
```java
// 불필요한 기능이었던 play와 pause가 제거되었다.
class SoundRecorder implements Recordable {
    public void record() {
        System.out.println("Recording audio");
    }
    public void stop() {
        System.out.println("Recording is stopped");
    }
}
```
##### **DIP : 의존관계 역전 원칙 (Dependency Inversion Principle)**
- 사용자가 상속 관계로 이루어진 모듈을 가져다 사용할 때, 하위 모듈의 인스턴스를 직접 가져다 쓰지 말고, 상위 인터페이스 타입의 객체를 사용하라는 원칙이다.
- 하위 모듈을 가져다 사용하게 된다면, 해당 모듈에 변화가 있을 때마다 상위 모듈의 코드를 자주 수정해야 되기 때문이다.
```java
// DIP를 따른 코드 예시
List<String> list1 = new ArrayList()<>;
Map<int,String> map1 = new HashMap()<>;
```
- 이와 같이 ArrayList나 HashMap 자료형을 인스턴스화 할 때, 변수 타입을 List나 Map의 인터페이스 타입으로 선언하여 인스턴스화 하는 것도 DIP 원칙을 따른 코드 선언이라고 볼 수 있다.

```java
// . DIP를 위반한 설계
public class Huni {
    private Galaxy tablet;
    public void setTablet(Galaxy tablet) {
        this.tablet = tablet;
    }
    public void PowerOn() {
        tablet.powerOn();
    }
}
// Huni 클래스는 Galaxy라는 구체적인 클래스에 의존하고 있습니다.
// 만약 Tablet을 Ipad로 변경하려면 Huni 클래스도 수정해야 합니다.
```

```java
public interface Tablet {
    String getName();
    void setName();
    void powerOn();
}
public class Ipad implements Tablet {
    private String name;
    private String model = "IPAD"
    
    @Override
    public String getName(){
        return model + name;
    }
    
    @Override
    public String setName(String name) {
        this.name = name;
    }
    
    @Override
    public void powerOn() {
        System.out.println("Hello " + model);
    }

    public void appleSync() { }
}

public class Galaxy implements Tablet {
    private String name;
    private String model="GALAXY"

    @Override
    public String getName(){
        return model + name;
    }

    @Override
    public String setName(String name) {
        this.name = name;
    }

    @Override
    public void powerOn() {
        System.out.println("Hello " + model);
    }
}

public class Main{
    public static void main(String[] args) {
        Galaxy galaxy = new Galaxy();
        Huni huni = new Huni();
        huni.setTablet(galaxy);
        huni.PowerOn();
    }
}
```
```java
//만약, Huni 클래스가 Galaxy를 사용하지 않고, Ipad를 사용하게 된다면 Ipad 태블릿의 set 메서드가 또 필요하게 된다.
public class Huni {
    private Galaxy galaxy;
    private Ipad ipad;

    public void setTablet(Galaxy galaxy) {
        this.galaxy = galaxy;
    }

    public void setTablet(Ipad ipad) {
        this.ipad = ipad;
    }

    public void PowerOn(){
        if(galaxy != null) galaxy.powerOn();
        if(ipad != null) ipad.powerOn();
    }
}
```
```java
// 의존 역전 법칙을 적용하여 보면 다음과 같다.
public class Huni {
    private Tablet tablet;

    public void setTablet(Tablet tablet) {
        this.tablet = tablet;
    }
    public void PowerOn(){
        this.tablet.powerOn();
    }
}
public class Main{
    public static void main(String[] args) {
        Tablet tablet = new IPAD();
        Huni huni = new Huni();
        huni.setTablet(tablet);
        huni.powerOn();
    }
}
//Huni의 코드는 아무런 변화 없이, Tablet 클래스를 상속 받는 클래스를 추가시켜 주면서 태블릿의 종류를 변화시켜 주고 있다.
```

### **IoC - 제어의 역전(Inversion of Control)**  
- IoC와 DI는 스프링의 가장 기본이 되는 기술이자 스프링의 핵심 개발 원칙
- POJO → AOP와 PSA도 IoC/DI에 바탕을 두고 있다.
> 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어역전(IoC)이라 한다.

#### **실생활에서의 예시**
- 운전 제어의 예 1
  - 자동차 운전을 직접 한다 가정하자. 다음과 같은 프로세스로 운전자는 운전을 할 것이다.
1. 목적지 설정
2. 차량의 속도 설정
3. 신호 및 교통체계 준수
- 이 경우 운전자는 운전에 관한 **모든 제어**를 담당하게 된다.

> 만약 직접 운전하는 것이 아닌 택시를 타거나 대리운전을 이용한다 가정하자.
> 그러면 탑승하는 순간부터 경로를 결정하거나 속도를 설정하거나 하는 모든 제어는 운전기사가 담당한다.
> 여기서 승객인 나는 목적지를 운전기사에게 “요청” 하기만 하면 되고, 나머지는 시스템인 > 운전기사가 처리한다.
> 즉, 운전에 대한 제어가 승객에서 운전기사로 역전이 된 것이다.

- 운전 제어의 예 2
  - 집에서 직접 식사를 준비한다 가정하자. 다음과 같은 프로세스로 요리할 것이다.
1. 메뉴 결정 및 재료 구입
2. 요리하기
3. 식탁에 요리 세팅하기
- 이 경우 메뉴 결정부터 요리하고 식탁에 올리기까지 식사 준비 제어권이 모두 나에게 있다.

>만약 식사를 하기 위해 직접 집에서 요리를 하는 것이 아닌 레스토랑에 가서 식사를 한다고 가정하자.
>나는 레스토랑에 들어가서 요리사에게 “주문”하기만 하면 요리 재료 준비부터 플레이팅까지 요리사가 진행한다.
>즉, **요리에 대한 제어가 내가 아닌 요리사에게** 역전이 된 것이다.

#### **소프트웨어에서의 IoC**
- 과거에는 개발자가 프로그램의 흐름을 직접 관리해야 했다. 개발자가 직접 객체를 생성하고 의존성을 설정하며, 객체 간의 상호작용까지 관리한다.
- 이것은 직접 운전을 하거나 요리를 하는 것과 같이 모든 결정과 관리는 개발자에 의해 이루어지는 것이다.
- 개발자가 직접 모든 것을 관리하게 되면 다음과 같은 단점이 있다.

1. 강한 결합도
- 객체 간의 강한 결합도는 하나의 객체가 변경될 때 다른 객체에도 영향을 미치는 상황을 의미함
- 개발자가 객체를 직접 생성하고 관리하기 때문에 객체를 변경할 경우 사이드 이펙트가 발생할 가능성이 높음
- 객체가 서로 밀집하게 연결되어 있어 객체를 분리해서 재사용하기 어려움
2. 유연성의 부족
- 소프트웨어 개발에서 유연성이라는 것은 코드를 쉽게 변경하거나 확장할 수 있는 능력을 의미함
- 직접 객체를 관리할 시 특정 서비스나 컴포넌트의 구현이 변경될 경우 관리하고 있는 모든 객체들이 영향을 받게 됨
3. 테스트 어려움
- 객체를 직접 제어해서 의존성을 관리하기 때문에 테스트 시 의존성을 모의 객체나 스텁으로 교체하기 어려울 수 있음
- 테스트를 위해 의존성을 분리하는 것이 매우 복잡하고 어려움

> 운전자가 직접 운전을 하는 것이 아닌 운전기사에게 맡기거나 요리를 직접 하는 것이 아닌 요리사에게 맡기는 것과 같이 개발자가 직접 객체와 의존성을 관리, 생명주기 관리를 하는 것이 아닌 스프링이 직접 하는 것을 우리는 제어의 역전이라 한다.
> 스프링 프레임워크에 제어권을 위임하게 되면 기존에 개발자가 모든 제어권을 가지고 관리를 할 때 생기는 문제점(강한 결합도, 유연성 부족, 테스트 어려움 등)을 해결할 수 있다.


#### **IoC가 적용되지 않은 예**
- 일반적인 상황에서는 개발자가 직접 객체를 제어해야 했다.
  - new 연산자를 통해 객체를 생성하고, 각 객체에 대한 라이프 사이클(설정, 초기화, 호출 등등)을 개발자가 직접 관리했다.
```java
public class Snack {
    private Juice juice;

    public Snack() {
        juice = new Juice();
    }
}
```
- Snack 클래스는 Juice 타입의 juice 필드를 갖고 있다.
- 생성자에서 Snack 객체가 생성될 때마다 Juice 클래스의 새로운 객체를 생성하고 있다.

#### **IoC가 적용된 예**
- 일반적인 상황에서는 개발자가 직접 객체를 제어해야 했다.
  - new 연산자를 통해 객체를 생성하고, 각 객체에 대한 라이프 사이클(설정, 초기화, 호출 등등)을 개발자가 직접 관리했다.
```java
public class Snack {
    @Autowired
    private Juice juice;
}
```
- 위 코드는 Spring 프레임워크에서 사용되는 @Autowired 어노테이션을 통해 의존성을 주입받고 있다.
- 즉, Snack 클래스가 Juice 객체를 직접 생성하는 것이 아닌, 외부에서 주입 받아 사용하게 되어 제어의 역전이 적용된 형태가 된다.

#### **Spring IoC 컨테이너와 Bean**
##### **컨테이너 (IoC 컨테이너)**
> Bean 객체들을 설정 파일에서 읽어서 관리하고, 사용자 대신 프레임워크 측면에서 객체들을 생성하거나 주입하는 컨테이너

- Spring IoC Container가 관리하는 객체를 **빈(Bean)** 이라고 한다.
- 빈(Bean)들의 생명 주기를 관리한다는 의미로 **빈 팩토리(BeanFactory)** 라고 한다.
- **스프링 컨테이너는 객체의 생명 주기를 관리하며, 제어의 역전을 통해 스프링 컨테이너 안에서 관리되는 빈(Bean)의 생명 주기를 관리**한다.

##### **빈(Bean)**
> Spring에 의해 생성되고 관리되는 자바를 **빈(Bean)**이라고 한다.
> 빈(Bean)은 스트링 IoC 컨테이너가 관리하는 객체이다.

- 의존성 관리가 용이하다.
- 기본적으로 스프링 컨테이너가 객체 인스턴스를 싱글톤 방식으로 관리한다.
  - **싱글톤 : 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴**

- 스프링은 자바 엔터프라이즈 기술을 사용하는 서버 환경이기 때문에 클라이언트의 요청을 받아 처리 할 때마다 내부에서 클래스 인스턴스를 계속 생성하게 되면 부하를 감당할 수 없게 된다.
- 싱글톤 디자인 패턴은 클래스의 객체가 단 하나 존재하게 하여 이러한 문제를 해결해줄 수 있다.
- 쉽게 생각하면 택시기사나 요리사를 스프링이 관리하는 대상 객체인 빈(Bean)으로 보면 되고, 이들을 관리하는 스프링 IoC 컨테이너는 택시 회사나 레스토랑이라 보면 된다.

#### **스프링 컨테이너 종류**

##### **빈 팩토리(BeanFactory)**
- 빈(Bean)을 등록하고 객체 생성, 조회, 호출 등의 다양한 기능을 담당
- 빈 팩토리(BeanFactory)는 빈의 정의는 즉시 로딩해 오지만 빈(Bean)이 사용되기 전 까지는 인스턴스화 하지 않는다.
- getBean() 메소드를 통해 호출되면, 빈 팩토리(BeanFactory)는 의존성 주입을 통해 빈(Bean)을 인스턴스화 하고 빈(Bean)의 특성을 설정하기 시작한다. 즉, 해당 시점부터 빈(Bean)의 생명이 시작된다.
##### **애플리케이션 컨텍스트(ApplicationContext)**
- 애플리케이션 컨텍스트(ApplicationContext)는 빈 팩토리(BeanFactory)를 상속해 확장한 컨테이너
- 하는 역할은 빈 팩토리와 동일하며, 추가로 스프링이 제공하는 여러 부가 기능을 제공한다. (Transaction 관리, AOP 처리 등)
- 애플리케이션 컨텍스트는 빈 팩토리와는 달리 초기화 시점에 빈(Bean)을 생성해 두기 때문에 빈(Bean)이 필요할 때 즉시 사용할 수 있다.

###### **애플리케이션 컨텍스트의 시작과 종료 과정**
- **애플리케이션 컨텍스트의 실행 시점**
1. 스프링 부트스트랩 클래스의 main() 메소드 호출
> SpringApplication 클래스의 run() 메소드가 호출됩니다.
> run() 메소드는 애플리케이션 컨텍스트를 생성하고 초기화합니다.
2. 애플리케이션 컨텍스트 초기화
> 빈 객체 생성 및 의존성 주입
> 빈 객체의 초기화 메소드 호출
> 애플리케이션 설정 및 환경 설정 로드
3. 애플리케이션 컨텍스트 시작
> 컨테이너에 등록된 모든 빈 객체가 사용 가능하게 됩니다.
> 애플리케이션 서버가 시작되고 요청을 처리할 준비가 됩니다.

- **애플리케이션 컨텍스트 종료 시점**
> 애플리케이션 서버가 종료될 때
> SpringApplication 클래스의 close() 메소드 호출
> ApplicationContext 인터페이스의 close() 메소드 호출

- **애플리케이션 컨텍스트 종료 시 수행 작업**
> 빈 객체 소멸
> 컨테이너 리소스 해제



#### **빈을 스프링 컨테이너에 등록하는 방법**
1. @Bean 이용하기
- 빈을 수동으로 등록하려면, 설정 클래스 파일을 만들어 @Configuration 어노테이션을 적용해 주고, 해당 클래스 내부에서 스프링 빈으로 등록할 메서드에 대해 @Bean 어노테이션을 적용시켜 주면 등록된다.
```java
@Configuration
public class AppConfig {
    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
    @Bean
    public MyRepository myRepository() {
        return new MyRepositoryImpl();
    }
}
```
2. 클래스 레벨에 @Component 이용하기
- 스프링에서는 컴포넌트 스캔을 이용하여 @Component가 붙은 모든 요소들을 빈으로 자동 등록 시켜준다.
- 클래스 레벨에 적용되는 @Component 어노테이션은 주로 스프링에서 자주 사용되는 다른 애너테이션 속에 포함되어 적용되는 경우가 많다.
  - 대표적인 어노테이션 종류

| 종류            | 설명                                                                                           |
|-----------------|------------------------------------------------------------------------------------------------|
| **@Controller** | 사용자로부터 요청이 들어오면 해당 업무를 처리하는 모델을 호출하고, 결과를 뷰에 전달하는 역할을 담당하는 컨트롤러 레이어에 적용된다. |
| **@Service**    | 사용자의 요구 사항을 처리하는 비즈니스 로직을 작성하는 서비스 레이어에 적용된다.               |
| **@Repository** | 스프링 MVC 패턴에서 해당 클래스에 대해 Repository 역할을 적용하여 DB 등의 외부 통신을 담당한다. |
| **@Configuration** | 빈 등록을 위해 사용하는 애너테이션이지만, 내부에는 `@Component`가 내장되어 있다.                       |
- @Controller 사용 예시
```java
@Controller
public class MyController {
    @GetMapping("/greeting")
    public String greeting() {
        return "Hello, World!";
    }
}
```
- @Repository 사용 예시
```java
@Repository
public class MyRepository {
    public String getData() {
        return "Data from database";
    }
}
```
- @Service 사용 예시
```java
@Service
public class MyService {
    public String provideService() {
        return "Service has been provided";
    }
}
```

---

### **DI - 의존성 주입**  
#### **의존성(Dependency)**
- 의존성 주입(Dependency Injection)은 의존성(Dependency)을 주입(Injection)하는 것.
> 의존성: 한 객체의 코드에서 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 의존성이 발생한다고 할 수 있다.
##### **결합도(Coupling)**
- 의존성의 정도를 결합도(Coupling) 라고 한다.
  - 결합도가 높으면 강한 결합 (Tight) 이라고 표현한다.
  - 결합도가 낮으면 느슨한 결합 (Loose) 이라고 표현한다.
- 일반적으로 new 연산자를 사용하여 객체를 생성할 때 강하게 결합하며,
- 인터페이스와 같이 일반화 된 구성 요소에 의존하고 있을 때 느슨하게 결합하게 된다.
```java
//강한 결합
class YourPhone {
private Iphone iphone;
    public YourPhone() {
        this.iphone = new Iphone();
    }
    public void PowerOn(){
        iphone.On();
    }
}
class Iphone {
    public void On() {
        String message = "Iphone On";
        System.out.println(message);
    }
}
// 만약 아이폰에서 갤럭시로 휴대폰을 교체하는 경우를 생각해보자.
// 갤럭시에 대한 멤버 변수를 생성해야 하고. . .여러가지 코드가 변경 되어야 한다.
```
```java
// 느슨한 결합
interface Phone(){
    void On();
}
class YourPhone {
    private Phone phone;
    public YourPhone(Phone phone) {
        this.phone = phone;
    }
    public void PowerOn(){
        phone.On();
    }
}
class Iphone implements Phone{
    @Override
    public void On(){
        String message = "Iphone On";
        System.out.println(message);
    }
}
class Galaxy implements Phone {
    @Override
    public void On() {
        String message = "Galaxy On";
        System.out.println(message);
    }
}
// 인터페이스 클래스를 이용해 추상화 하여 클래스 간의 의존성을 최소화 하였다.
// 느슨한 결합은 요구 사항의 변경에 유연한 대처가 가능해진다.
```
#### **의존성 주입(Dependency Injection)**
> 의존성 주입(DI)은 자신이 사용할 객체에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 객체를 사용한다는 것.
- 이처럼 개발자는 수동적으로 주입 받은 객체를 사용한다는 점에서 앞에서 학습했던 IoC의 개념에 잘 들어맞는다. ⇒ 즉, 스프링 컨테이너의 IoC는 주로 의존성 주입에 초점이 맞춰져 있다.
- 스프링을 IoC 컨테이너 외에도 DI 컨테이너라고 부르기도 하는 이유이다.
##### **DI의 장점**
- 클래스들 간의 강한 결합을 느슨한 결합으로 만들어 준다. ⇒ 요구사항의 변경에 유연하게 대처할 수 있도록 해준다.
- 테스트가 자유로워진다. ⇒ 결합도가 낮기 때문
#### **의존성 주입 방법**
##### **생성자 주입**
- 생성자를 통해서 의존 관계를 주입 받는 방법.
- 생성자에 @Autowired를 하면 스프링 컨테이너에 @Component로 등록된 빈(Bean)에서 생성자에 필요한 빈(Bean)을 주입한다.
```java
@Component
public class AirpodsController {
    private final AirpodsService airpodsService;

    public AirpodsController(AirpodsService airpodsService) {
        this.airpodsService = airpodsService;
    }
}
```
- 생성자 주입의 특징
  - 생성자 호출 시점에 1번만 호출되는 것을 보장하기 때문에 이후 값을 변경하지 못 하게 막을 수 있다.
    - 불변과 필수 의존 관계에 사용된다.
    - 불변 : 생성자를 통해서만 의존 관계가 주입되고, 외부에서 수정할 수 없다.
    - 필수 : 무조건 값이 있어야 한다.
  - 생성자가 1개만 존재하는 경우 @Autowired를 생략해도 자동 주입 된다.
  - 주입 받을 필드를 final로 선언할 수 있다. (오직 생성자 주입 방식만 final 키워드를 사용할 수 있다!)
  - final로 선언된 레퍼런스 타입의 변수는 반드시 선언과 동시에 초기화가 이루어 져야 한다.
  - final로 선언된 변수는 객체가 불변하도록 할 수 있다는 장점이 있다. 코드의 신뢰성, 유지보수성, 가독성 향상을 시킬 수 있다.
##### **수정자(setter) 주입**
- 필드의 값을 변경하는 수정자 메서드를 통해 의존 관계를 주입하는 방법이다.
```java
@Component
public class AirpodsController {
    private AirpodsService airpodsService;

    @Autowired
    public void setAirpodsService(AirpodsService airpodsService) {
        this.airpodsService = airpodsService;
    }
}
```
- 수정자 주입의 특징
  - 선택과 변경 가능성이 있는 의존 관계에 사용한다.
    - 선택 : 스프링 빈으로 등록되지 않은 인스턴스 또한 주입이 가능하다.
    - 변경 : 변경 가능성 있는 의존 관계 사용시, 중간에 setter메서드를 호출하여 의존 관계를 변경할 수 있다.
  - 수정자 메서드를 이용해서 의존 관계를 주입한다.
  - @Autowired를 입력하지 않으면 실행이 되지 않는다.

###### **자바빈 프로퍼티
> Java에서는 필드의 값을 직접 변경하지 않고 set, get 메서드를 통해 값을 읽어 오거나 수정하는 규칙을 만들었는데, 이를 자바빈 프로퍼티 규약이라고 한다.
- 즉, 자바빈 프로퍼티 규약의 수정자(set) 메서드 방식을 사용하는 방법이다
##### **필그 주입**
- 변수 선언부에 @Autowired를 붙여 주입하는 방법이다.
```java
@Component
public class AirpodsController {
    @Autowired
    private AirpodsService airpodsService;
}
```
- 의존성을 주입하기 쉽다.
- 참조 관계를 눈으로 확인하기 어렵다.
> **생성자 주입 방식을 사용하자**
> 1. Spring 프레임워크에서는 생성자 주입을 권장하고 있다.
> 2. IntelliJ에서도 필드 주입은 권장하지 않으며, Spring Team은 **생성자 주입을 사용하는 것을 권장**한다고 이야기 해준다.

- 필드 주입의 단점
  - 필드 주입은 Spring같은 DI를 지원하는 프레임워크가 있어야만 사용할 수 있다.
  - 테스트 코드를 순수 자바 코드로 작성하기 어려우며, 테스트가 특정 프레임워크에 의존하는 것은 침투적이기에 좋지 않다.
  - 필드 주입으로 의존성 주입 시 final 키워드를 통한 선언이 불가능하고 객체가 변하기 쉬워진다.
- 수정자 주입의 단점
  - Set 메서드의 경우 public으로 구현하기 때문에 관계를 주입 받는 객체의 변형 가능성이 있다.
  - 즉, 객체가 변경 될 필요성이 있을 때 사용이 권장된다.
- 생성자 주입의 장점
  - 생성자 주입은 **“객체의 불변성을 확보”** 할 수 있다. (final 키워드 사용 가능)
    - 객체의 생성자는 객체 생성 시 1회만 호출 되는게 보장된다.
    - 즉, 주입 받은 객체가 불변 객체로 설계할 수 있으며, 의존성 주입을 누락하는 것을 방지할 수 있다.
  - 생성자 주입은 **“애플리케이션 구동 시점에 순환 참조 에러”**를 알려준다.
    - 생성자 주입은 객체의 생성과 의존 관계 주입이 동시에 실행되지만, @Autowired는 모든 객체의 생성이 완료된 후에 의존 관계 주입이 처리되기에 호출이 되고 나서야 순환 이슈를 확인할 수 있다.
```java
public class ClassA {
    private ClassB classB;

    @Autowired
    public ClassA(ClassB classB) {
        this.classB = classB;
    }
}
public class ClassB {
    private classA classA;

    @Autowired
    public ClassB(ClassA classA) {
        this.classA = classA;
    }
}
```

---

### **AOP - 관점 지향 프로그래밍**  
#### **AOP란?**
> AOP(Aspect-Oriented Programming) → 관점 지향 프로그래밍을 의미한다다
- **핵심 관심사**와 **횡단 관심사**에 대한 관점들로 프로그램을 분해하여 객체 지향이 추구하는 모듈을 효과적으로 지원하도록 하는 프로그래밍 기법을 의미한다.
- 기능별로 모듈을 분리 했음에도 불구하고 생기는 중복 코드의 단점을 해결하고자 나온 방식으로, **공통 기능과 핵심 기능을 분리하여 필요할 때만 공통 기능을 핵심 기능에 넣어주는 형식**
![image](https://github.com/user-attachments/assets/3b749e11-866d-4806-8465-e1d62a81b139)

- 핵심 기능
  - 비즈니스 로직에 대한 관심사로, 애플리케이션 로직이 제공하는 고유의 업무 로직
- 공통(부가) 기능
  - 핵심 관심사를 보조하기 위해 제공되는 기능
  - 로그, 보안, 트랜잭션 기능 등
  - 단독으로 사용되지 않고 핵심 기능과 함께 사용

#### **실생활에서의 AOP 예시 1**
- 대학교 강의
- 대학에서 여러 강의를 듣고 있다고 가정해보자. 강의는 다음과 같은 프로세스로 진행이 된다.
  - 1. 출석 확인
  - 2. 강의 진행
  - 3. 중간고사 및 기말고사
  - 4. 성적 처리
- 이러한 프로세스는 모든 강의에 해당되는 것이다.

- 여기서 **핵심 관심사(Core Concerns)**는 각각의 강의가 가지고 있는 독특한 내용과 각각에 맞춘 평가 방식이다.
  - 알고리즘 강의의 알고리즘 문제 풀이
  - 데이터베이스 강의의 데이터베이스 설계
![image](https://github.com/user-attachments/assets/12d02f8d-6393-4ddf-bad6-de73bb3d5e3b)
- 반면에 횡단 관심사(Cross-cutting Concerns)는 출석 관리, 시험 관리, 성적 평가와 같이 모든 강의에서 공통적으로 필요하지만, 각각의 핵심 내용과는 직접적인 관련이 없는 활동들을 의미한다.
- 즉, 이러한 활동들은 모든 강의에 걸쳐 일관되게 발생하며, 각 강의의 주된 목표를 달성하기 위해 필수적이지만 보조적인 역
할을 수행한다.
![image](https://github.com/user-attachments/assets/2ea29d4b-5c76-429c-b1c9-426f5728eb0a)
- 따라서, **핵심 관심사와 횡단 관심사를 명확히 분리**하여 관리하는 것이 바람직하다.
#### **실생활에서의 AOP 예시 2**
- 쇼핑 프로세스
- 우리가 마트에 간다고 가정해보자. 목적에 따라 옷 가게를 가거나, 가구 매장에 가거나, 서점에 갈 수 있다.
다음은 쇼핑할 시 행위에 대해 정의한 것이다.
  - 1. 쇼핑할 물건 고르기
  - 2. 장바구니 담기
  - 3. 결제하기
  - 4. 영수증 받기
- 해당 프로세스는 어느 가게를 가더라도 동일하게 행해질 것이다.
- 여기서 핵심 관심사(Core Concerns)는 가게마다 고르는 물건이 다르고 구매를 결정하는 요인이 다르다는 것이 핵심이다.
  - 옷의 사이즈나 색상이 나와 잘 맞는 지 피팅하기
  - 구매하려는 가구가 실측된 공간에 맞는 지 사이즈를 확인하기
  - 구매하려는 책이 내가 원하는 주제나 방향성이 맞는지 확인하기
![image](https://github.com/user-attachments/assets/67053ec8-3c0a-4cbf-94b8-0a82aee69274)
- 반면에 횡단 관심사(Cross-cutting Concerns)는 장바구니 담기, 결제, 영수증 받기와 같이 모든 쇼핑에서 공통적으로 필요하지만, 각각의 핵심 내용과는 직접적인 관련이 없는 활동들을 의미한다.
![image](https://github.com/user-attachments/assets/54e240f8-bccd-418f-8691-a8695e89ddc9)
- 이렇게 핵심 관심사와 횡단 관심사를 명확히 분리하여 관리하면 얻는 이점은 다음과 같다.

#### **핵심 관심사와 횡단 관심사 분리 이점**
1. **유지보수성 향상**
 - 코드가 더 명확해지고 가독성이 향상됨
 - 수정이 필요한 경우 핵심 비즈니스 로직이나 반복되는 기능 중 변경할 위치를 찾기 쉬움
2. **코드 재사용성 증가**
 - 횡단 관심사를 분리하여 모듈화함으로써 같은 기능이 필요한 다른 부분에서 이를 재사용할 수 있음
 - 예를 들어, 로깅, 보안 검증, 트랜잭션 관리 같은 기능들을 여러 컴포넌트에서 공유할 수 있음
 - 중복 코드를 줄이고 프로젝트의 일관성을 유지할 수 있음
3. **테스트 용이성**
 - 핵심 로직이 횡단 관심사로부터 분리되면 핵심 기능을 독립적으로 테스트하기가 훨씬 쉬워짐
 - 특히, 단위 테스트를 수행할 때 필요한 설정이 줄어들어 테스트 작성이 간단해지고 빠른 수행 가능함
4. **에러 추적과 디버깅 용이성**
 - 프로그램의 특정 부분에서 문제가 발생했을 때 오류의 원인을 찾아내기
5. **시스템의 확장성 향상**
 - 횡단 관심사를 모듈화하고 일관된 방식으로 적용함으로써 새로운 기능을 시스템에 통합하기가 더 쉬워짐
 - 또한, 시스템을 확장하거나 변경해야 할 때 핵심 로직에 미치는 영향을 최소화할 수 있음
6. **명확한 책임 분리**
 - 각각의 모듈이나 컴포넌트가 명확한 책임을 가지고 있음

#### **AOP 간단 용어 설명**
- **애스팩트(Aspect)**
  - 핵심 기능에서 분리한 **부가 기능**과, 이를 **어디에 적용할 지**를 정의한 것
  - 횡단관심사를 구현하는 코드를 **캡슐화**하는 역할
  - 어드바이스와 포인트컷을 포함
- **어드바이스 (Advice)**
  - 애스팩트(Aspect)에서 정의되는 메소드
  - 횡단관심사를 구현하는 **실제 코드**를 담고 있음
 - Before, After, Around 등 다양한 종류가 존재함
- **조인포인트(Join Point)**
  - 애스팩트(Aspect)가 적용될 수 있는 특정 지점
  - 메서드 실행, 필드 접근, 객체 생성 등 다양한 시점에 발생
  - AOP 프레임워크에서 제공
- **포인트컷(Pointcut)**
  - 조인포인트 중에서 애스팩트가 실제로 적용될 조건 또는 기준을 정의
  - 조인포인트들을 필터링하여 애스팩트 적용 위치를 결정
  - execution, within, this 등 다양한 표현식 사용 가능
> 관점 지향 프로그래밍은 **공통 기능(트랜잭션, 로그, 보안 등)을 비즈니스 로직에서의 관점을 바탕으로 분리하여 객체 지향 프로그래밍 방식의 불필요한 반복을 해결하기 위한 방법**
> 부가 기능이 불특정 다수의 여러 곳에 작성되는 경우를 방지한다.
> 부가 기능 수정 시 사용된 모든 클래스를 수정하는 것이 아닌 하나로 관리할 수 있게 해준다.

---

### **PSA (Portable Service Abstraction)**  

#### **PSA(Portable Service Abstraction)**
> PSA(Portable Service Abstraction) → 일관성 있는 서비스 추상화화
- 애플리케이션에서 특정 서비스를 이용할 때, 서비스의 기능에 접근하는 방식 자체를 일관된 방식으로 유지하며 기술
자체를 유연하게 사용할 수 있도록 하는 것을 PSA(일관성 있는 서비스 추상화) 라고 한다.
- **즉, 환경과 세부 기술의 변화 없이 일관된 방식으로 기술에 접근할 수 있게 해주는 것**

#### **실생활에서의 예시 1**
- 게임기 예시
  - 하나의 범용 컨트롤러가 모든 콘솔에서 작동한다고 가정하자
  - 사용자는 새로운 콘솔을 살 때마다 새로운 컨트롤러를 배우지 않아도 된다

- PSA 개념이 적용된 게임 컨트롤러의 장점
  - 새로운 컨트롤러를 매번 배우는 불편함 없이 바로 **게임 플레이에 집중 가능**
  - 다양한 환경에서 **일관된 게임 플레이 경험** 제공
  - 개인화된 컨트롤러 설정 및 느낌 모든 게임에 적용 가능
  - 별도의 컨트롤러를 각 콘솔마다 구입할 필요가 없으므로 사용자는 장비에 들어가는 **비용을 절약**할 수 있음
#### **실생활에서의 예시 2**
- 스포츠 예시
  - 축구, 야구, 농구와 같은 스포츠는 모두 구기종목에 해당한다. 게임하는 방식은 달라도 “공을 던지고(또는 발로 차거나) 받는” 행위로 이루어진다.
  - 만약, 이러한 행위를 별도로 분리하면 무슨 종목을 수행하더라도 공을 던지고 받는 게임 자체에 집중할 수 있다.
- PSA 개념이 적용된 구기종목의 장점
  - 기본적인 '공을 넘기고 받는' 기술을 배움으로써 여러 구기종목(축구, 농구, 배구 등)에서 활용 가능
  - 새로운 또는 다른 규칙을 가진 스포츠에 빠르게 적응할 수 있고, 특정 규칙이나 전략에 더 집중할 수 있음
  - 하나의 기술 세트로 여러 스포츠를 커버할 수 있기 때문에 다양한 스포츠에 대한 별도의 훈련이나 장비 구매 비용을 절약할 수 있음
#### **PSA와 트랜잭션**
##### **트랜잭션(Transaction)**
> 트랙잭션은 **[쪼갤 수 없는 업무 처리의 최소 단위]**를 말한다.
- 트랜잭션에는 4가지의 특징이 있다.
- **원자성** : 트랜잭션 실행은 모두 완료되거나, 실패 시 이전으로 돌아가야 한다.
- **일관성** : 트랜잭션의 작업 결과가 항상 일관성이 있어야 한다.
- **독립성** : 둘 이상의 트랜잭션이 동시에 실행되는 경우, 서로 독립적으로 실행되어야 한다.
- **지속성** : 트랜잭션이 성공적으로 완료되었을 경우, 결과가 영구적으로 반영된다.
##### **스프링 PSA**
- 스프링은 **[원자성, 일관성, 독립성, 지속성]**을 지원하기 위해 인터페이스를 제공한다.
![image](https://github.com/user-attachments/assets/3d597913-a941-4542-ac95-fd92f0a5389e)
- 스프링 프레임워크에서 트랜잭션을 관리하는 인터페이스로 [PlatformTransactionManager]가 있다.
  - 여러 트랜잭션 관리 기술 중에는 JDBC / JTA / Hibernate 등이 있다.
- JDBC , JTA, Hibernate는 각각 다른 트랜잭션 관리 기술을 사용하지만 해당 인터페이스를 통해 여러 트랜잭션 관리 기술을 추상화하고, 개발자에게 동일한 트랜잭션 관리 인터페이스를 제공한다.
- 즉, 스프링은 PSA를 통해 개발자에게 트랜잭션 관리 기술(JDBC / JTA / Hibernate)에 구체적으로 종속되지 않고 동일한 방식(동일한 메서드)으로 트랜잭션을 다룰 수 있도록 돕는다.

#### **스프링에서의 PSA 적용 기술**
##### **Spring JPA**
> JPA(Java Persisitence API)는 Java 어플리케이션에서 관계형 데이터베이스를 객체-관계 방식(ORM)으로 사용할 수 있도록 만든 인터페이스
- JPA를 사용하면, 다양한 데이터베이스 시스템(예: MySQL, Oracle, PostgreSQL 등)에 동일한 객체 관계 매핑을 사용할 수 있다
- 개발자는 데이터베이스의 종류에 관계없이 동일한 코드와 API를 사용하여 데이터를 관리할 수 있으므로, 새로운 데이터베이스 시스템을 배울 때의 학습 곡선이 줄어든다

##### **JPA 특징**
- 객체-관계 매핑 (ORM)
  - JPA는 객체 지향 프로그래밍 언어에서 사용하는 객체와 관계형 데이터베이스의 테이블 사이의 매핑 제공
  - 이를 통해 개발자는 데이터베이스 테이블을 직접 다루는 대신 자바 객체로 작업할 수 있음
- 데이터베이스 독립성
  - 개발자는 JPA를 사용함으로써 특정 데이터베이스 SQL에 종속되지 않고 같은 코드를 다양한 데이터베이스 시스템에서 사용할 수 있음
- 추상화
  - PA는 데이터베이스 접근 로직을 추상화한 기술
  - JPA 애플리케이션은 SQL 쿼리를 직접 작성하지 않고도 객체 지향 방식으로 데이터를 쿼리할 수 있음
- 트랜잭션 관리
  - JPA는 데이터베이스 트랜잭션을 관리하고 트랜잭션 컨텍스트 내에서의 엔티티의 일관성을 보장함
> → JPA를 사용함으로써 개발자는 객체 지향적이고 데이터베이스에 독립적인 방식으로 애플리케이션을 개발할 수 있다.

#### **정리**
- 추상화 된 상위 클래스를 일관되게 바라보며 하위 클래스의 기능을 사용하는 것이 바로 일관된 서비스 추상화
- 특정 서비스를 이용할 때, 서비스의 기능 접근 방식 자체를 일관되게 유지하며, 기술 자체를 유연하게 사용할 수 있도록 하는 것이 PSA이다.
> → 기술과 서비스에 대한 추상화 기법으로 특정 기술 환경에 종속되지 않는 코드를 만들 수 있다

---

### **Spring Boot**  
#### **Spring Boot**
- 스프링 공식 문서에서 소개하는 스프링 부트는 다음과 같다.
  - 스프링 부트는 단독 실행이 되는 실행하기만 하면 되는 상용화 가능한 수준의 스프링 기반 애플리케이션을 쉽게 만들수 있다.
  - 최소의 설정으로 스프링 플랫폼과 third-party 라이브러리들을 사용할 수 있다.
> **즉, 스프링 기반의 애플리케이션을 개발하기 쉽도록 설정의 많은 부분을 자동화하여 사용자가 편하게 스프링을 활용할 수 있게 돕는다.**
![image](https://github.com/user-attachments/assets/2c2f4dcf-bc33-4214-841a-1902c602ced6)
- 스프링 부트는 스프링 프레임워크 위에 구축되었음. 이는 스프링의 핵심 기능인 의존성 주입, 트랜잭션 관리, 웹 개발, 데이터 접근 등을 스프링 부트 애플리케이션에서도 사용할 수 있음을 의미함
- 스프링 부트는 기본적으로 스프링 프레임워크의 간소화된 버전이 아니라 스프링 애플리케이션을 더욱 빠르고 쉽게 개발할 수 있게 하는 확장 도구
- 스프링 프레임워크 외에도 스프링 데이터, 스프링 시큐리티, 스프링 배치와 같은 다른 스프링 프로젝트들과 함께 사용되어 강력하고 종합적인 개발 환경을 제공함

#### **Spring Boot의 특징**
- 스프링은 장점이 많은 프레임워크지만 **설정이 매우 복잡**하다는 단점이 존재한다.
- 이러한 **단점을 인식하고 보완하기 위해 스프링 부트가 탄생**하였다.
> 스프링 부트는 스프링 프레임워크를 더 쉽고 빠륵게 이용할 수 있도록 만들어주는 도구다.
- 빠르게 스프링 부트 프로젝트를 설정할 수 있고, 의존성 세트라고 불리는 starter를 사용해 간편하게 의존성을 사용하거나 관리할 수 있다.
- Create stand-alone Spring applications
  - 단독 실행 가능한 스프링 애플리케이션을 생성한다.
- Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)
  - 내장형 톰켓, 제티, 혹은 언더토우를 내장하고 있으며 [WAR 파일을 이용해 deploy(배포) 한다면 필요 없다.]
- Provide opinionated 'starter' dependencies to simplify your build configuration
  - 기본으로 설정되어 있는 ‘starter’ 컴포넌트들을 쉽게 추가할 수 있다.
- Automatically configure Spring and 3rd party libraries whenever possible
  - 자동 구성을 통해 설정이나 3rd-party 라이브러리를 구성할 수 있다.
- Provide production-ready features such as metrics, health checks, and externalized configuration
  - 상용화에 필요한 통계, 상태 점검 및 외부 설정을 제공한다.
- Absolutely no code generation and no requirement for XML configuration
  - 설정을 위한 XML 코드를 생성하거나 요구하지 않는다.

#### **starter**
> 스프링 부트에서는 starter(스타터) 개념을 도입해 개발자들이 프로젝트에 필요한 의존성을 빠르고 편리하게 관리할 수 있게 해준다.
- **편의성** : 스타터를 사용하게 된다면 여러 기술과 라이브러리에 대한 종속성들을 수동으로 추가하지 않아도 된다. 필요한 스타터만 프로젝트에 추가해주면 개발자는 필수적인 의존성을 간편하게 관리할 수 있다.
- **일관성** : 프로젝트에 필요한 라이브러리들이 일관성 있게 버전이 관리되며, 호환성 문제를 최소화 할 수 있다.
- **자동 구성** : 스타터는 프로젝트에 추가되면 자동으로 설정이 적용되어 개발자가 별도의 설정 없이도 기본적인 환경을 사용할 수 있도록 만들어준다.

```java
//[예시] Spring Data JPA
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
}

```
```java
//-JPA 스타터-
'org.springframework.boot:spring-boot-starter-data-jpa’
```

- 만약 JPA 기술을 사용하기 위해 JPA starter를 사용하면
  - Hibernate
  - Spring Data JPA
  - Spring ORM
  - Spring Transaction
  - Spring core
  - Spring Beans
- 등등의 여러 의존성을 한 줄의 starter 코드 만으로 설정할 수 있다.

> **스프링 부트 스타터는 개발자들이 프로젝트를 효율적으로 시작하고 관리할 수 있도록 도와주는 강력한 도구다.**
- 스프링 프레임워크 외에도 스프링 데이터, 스프링 시큐리티, 스프링 배치와 같은 다른 스프링 프로젝트들과 함께 사용되어 강력하고 종합적인 개발 환경을 제공함

---

---

## **Chap 3. 개발 환경 구축**

***

---

---

---



