--- 
title: "자바 | JAVA" 
date: 2024-11-26 09:40:00 +0900
achieved: 2024-11-29 17:30:00 +0900
math: true
categories: [Bootcamp, KT Aivle School]
tags: [Bootcamp, KT Aivle School, JAVA]
---
---------- 	
> JAVA 기초 정리 글입니다. 
{: .prompt-info } 

## **Chap 1. Java 소개**

***

### **프로그래밍 언어란?**
프로그래밍 언어는 컴퓨터와 인간을 연결하는 매개체로, 컴퓨터가 작업을 수행하도록 지시하는 도구입니다.

#### **프로그래밍 언어의 분류**
- **기계어 (Machine Language)**:
  - 컴퓨터가 직접 이해할 수 있는 0과 1로 구성된 저급 언어.
  - 사람이 작성하기 어렵고 유지보수가 힘듭니다.
- **고급 언어 (High-Level Language)**:
  - 인간이 이해하기 쉬운 문법으로 작성 가능하며 기계어로 컴파일(번역)하여 실행.
  - 예: C, C++, Java, Python 등.

#### **컴파일과 인터프리트**
- **컴파일러 언어**:
  - 소스 코드를 기계어로 번역 후 실행.
  - 실행 파일 생성.
  - 예: C, C++.
- **인터프리터 언어**:
  - 실행 시 코드 한 줄씩 해석하며 수행.
  - 실행 속도가 느리지만 유연성 높음.
  - 예: Python, JavaScript.

---

### **Java란?**
- 객체지향 프로그래밍 언어로 "Write Once, Run Anywhere"(한 번 작성하여 어디서나 실행 가능) 철학을 따릅니다.
- 자바는 플랫폼 독립적이며 다양한 환경에서 실행할 수 있습니다.

#### **Java의 역사**
- 1995년 Sun Microsystems에서 제임스 고슬링이 주도하여 개발.
- 2006년 Sun Microsystems는 Java를 오픈 소스로 공개.
- 2010년 Oracle이 Sun Microsystems를 인수하며 Java 관리.
- Java는 가전제품 프로그래밍으로 시작하여 웹, 모바일, 서버 등으로 확장.
- 현재는 6개월마다 새로운 버전이 출시되며 최신 기술 트렌드를 반영.

---

### **프로그래밍 개발 과정**

#### **C 언어 개발 과정**
1. **소스 파일 작성**: .c 확장자를 가진 파일 생성.
2. **전처리**: 헤더 파일 포함 및 매크로 확장.
3. **컴파일**: 구문 분석 및 최적화 수행, 어셈블리어로 변환.
4. **어셈블**: 어셈블리어를 기계어로 변환하여 오브젝트 파일 생성.
5. **링킹**: 여러 오브젝트 파일과 라이브러리를 결합하여 실행 파일 생성.
6. **실행**: 생성된 실행 파일을 시스템에서 실행.

#### **Java 개발 과정**
1. **소스 파일 작성**: .java 확장자를 가진 자바 소스 코드 작성.
2. **컴파일**: javac 컴파일러로 .class 파일(바이트 코드) 생성.
3. **로딩**: 클래스 로더가 .class 파일을 JVM에 로드.
4. **링킹**: 검증, 준비, 해석 단계를 거쳐 실행 준비.
5. **초기화**: 클래스 변수 초기화 및 정적 블록 실행.
6. **실행**: JVM의 인터프리터 또는 JIT 컴파일러가 바이트 코드를 실행.

---

### **JDK, JRE, JVM**

#### **JVM (Java Virtual Machine)**
- 자바 바이트 코드를 실행하기 위한 가상 머신.
- 플랫폼마다 다른 JVM을 제공하지만, 동일한 바이트 코드를 실행 가능.
- 주요 역할:
  1. 바이트 코드를 읽고 검증.
  2. 실행 환경(Runtime Environment)을 제공.

#### **JRE (Java Runtime Environment)**
- 컴파일된 자바 프로그램 실행을 위한 환경.
- JVM과 필요한 라이브러리 파일 포함.
- 자바 프로그래밍 도구는 포함되지 않음.

#### **JDK (Java Development Kit)**
- 자바 개발 도구와 라이브러리를 포함한 개발 환경.
- JRE와 개발 도구(javac, debugger 등)를 포함.

---

### **Java SE, EE, ME**

#### **Java SE (Standard Edition)**
- 데스크톱, 서버, 임베디드 시스템을 위한 표준 자바 플랫폼.
- 기본적인 API와 자바 가상 머신 규격을 포함.
- 예: JDBC를 포함하여 Android 개발에서도 활용.

#### **Java EE (Enterprise Edition)**
- 서버측 개발을 위한 자바 플랫폼.
- 분산 멀티미디어 및 웹 애플리케이션 서버에 필요한 기능을 제공.
- Java SE 기반으로 확장된 기능 포함.

#### **Java ME (Micro Edition)**
- 임베디드 시스템을 위한 경량화된 자바 플랫폼.
- 제한된 자원을 가진 휴대폰, PDA 등에서 사용.

---


## **Chap 2. Intellij 설치 및 개발 환경 설정**

***

### **Intellij IDEA 소개**
- Intellij IDEA는 **JetBrains**에서 만든 강력한 Java 개발 도구입니다.
- Java뿐만 아니라 다양한 언어를 플러그인을 통해 지원하여 멀티언어 개발 환경을 제공합니다.

#### **Intellij 버전**
1. **Ultimate 버전**: 상용 라이선스가 필요하며, 고급 기능과 기업용 개발에 적합한 도구를 제공합니다.
2. **Community 버전**: 무료로 제공되며, 기본적인 Java 및 Android 개발 기능을 포함합니다.

- 공식 사이트: [Intellij IDEA](https://www.jetbrains.com/ko-kr/idea/)
- Intellij는 **매년 3~4회** 정기 업데이트를 지원하여 최신 기능과 성능 향상을 제공합니다.

***


## **Chap 3. 자바 타입**

---

### **자바 타입의 종류**

#### **역할**
- 데이터가 저장되는 메모리와 프로그램에서의 처리 방식을 명시.

#### **종류**
- **기본형 타입 (Primitive Type):**
  - Stack 메모리에 실제 값을 저장.
  - 총 8종류 제공: `byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean`.
  - 정수형, 실수형, 문자형, 논리형으로 구분.
  - 선언한 타입의 표현 범위를 벗어나면 **오버플로우** 또는 **언더플로우**가 발생.
  - **오버플로우**: 표현 가능 최대값 초과. **언더플로우**: 표현 가능 최소값 미만.

- **참조형 타입 (Reference Type):**
  - Heap 메모리에 실제 값의 주소를 저장.
  - 총 4종류 제공: `array`, `enum`, `class`, `interface`.
  - 참조값을 통해 인스턴스를 핸들링.

#### **스택 메모리와 힙 메모리의 차이점**

| 메모리 타입   | 특징                                                                                         |
|---------------|---------------------------------------------------------------------------------------------|
| **스택 메모리** | 메서드 내의 지역 변수 저장소로 사용. 메서드 호출과 함께 할당되고, 메서드 종료 시 해제. 속도가 빠름. |
| **힙 메모리**  | 객체와 인스턴스가 저장되는 영역. 가비지 컬렉션의 대상이 되며, 메모리 관리가 복잡하고 유동적임.      |

#### **타입별 메모리 크기와 데이터 표현 범위**

| 타입 종류     | 메모리 크기 | 데이터 표현 범위                                               | 추가 정보               |
|---------------|-------------|----------------------------------------------------------------|-------------------------|
| **정수형 타입** |             |                                                                |                         |
| `byte`        | 1바이트     | -2<sup>7</sup> ~ 2<sup>7</sup> - 1                             |                         |
| `short`       | 2바이트     | -2<sup>15</sup> ~ 2<sup>15</sup> - 1                           |                         |
| `int`         | 4바이트     | -2<sup>31</sup> ~ 2<sup>31</sup> - 1                           |                         |
| `long`        | 8바이트     | -2<sup>63</sup> ~ 2<sup>63</sup> - 1                           |                         |
| **실수형 타입** |             |                                                                |                         |
| `float`       | 4바이트     | 1.4 × 10<sup>-45</sup> ~ 3.4 × 10<sup>38</sup>                 | 리터럴 접미사: `F`, `f` |
| `double`      | 8바이트     | 4.9 × 10<sup>-324</sup> ~ 1.7 × 10<sup>308</sup>               | 리터럴 접미사: `D`, `d` (생략 가능) |
| **문자형 타입** |             |                                                                |                         |
| `char`        | 2바이트     | 0 ~ 2<sup>16</sup>                                             | 유니코드 사용           |
| **논리형 타입** |             |                                                                |                         |
| `boolean`     | 1바이트     | `true`, `false`                                                | 기본 값: `false`        |

---

### **자바 변수**

#### **변수의 개념과 선언 방법**
- 변수는 정보를 저장할 수 있는 메모리 공간의 이름입니다.
- 선언 방법:
  - `[데이터 타입] [변수명];`
  - `[데이터 타입] [변수명] = [초기값];`

#### **변수명(식별자) 작성 규칙**
1. 변수명의 길이는 제한이 없습니다.
2. 반드시 문자, 언더바(_), 또는 달러기호($)로 시작해야 합니다.
3. 대소문자를 구분합니다.
4. 숫자가 첫 글자로 올 수 없으며, 공백은 사용할 수 없습니다.
5. 자바의 키워드는 변수명으로 사용할 수 없습니다.
6. 예제:
   ```java
   int myVariable = 10;  // 올바른 변수 선언
   int _shape3D = 5;     // 올바른 변수 선언
   int public = 100;     // 오류: 키워드 사용
   ```

---

### **자바 식별자**

#### **식별자 작성 규칙**
- 하나 이상의 문자로 이루어져야 합니다.
- 첫 번째 문자는 영문자, `$`, 또는 `_` 여야 합니다.
- `$`와 `_` 이외의 특수문자는 사용할 수 없습니다.
- 키워드나 상수 값을 표현하는 단어는 식별자로 사용할 수 없습니다.

#### **식별자 사용 예시**
- 여러 식별자를 함께 사용하는 경우 점(`.`)으로 연결:
  ```java
  System.out.println("Hello, Java!");
  ```

---

### **변수와 기본 데이터 타입 정리**

#### **기본 데이터 타입 선언 방법**
- `[데이터 타입] [변수명];`
- `[데이터 타입] [변수명] = [초기값];`
- `[데이터 타입] [변수명1], [변수명2];`

#### **예제**
```java
int number;          // 변수 선언
number = 10;         // 초기화
float price = 19.99; // 선언과 동시에 초기화
```

---

### **연산자 개요**

#### **연산자 종류 및 설명**
| 연산자 종류       | 연산자 및 설명                                                                 |
|-------------------|-------------------------------------------------------------------------------|
| 형변환 연산자     | `(cast)` : 하나의 항을 특정 데이터 타입으로 형변환해 주는 연산자.              |
| 산술 연산자       | `+`, `-`, `*`, `/`, `%`, `+=`, `-=`, `*=`, `/=`, `%=` : 기본적인 산술 연산 수행. |
| 관계 연산자       | `>`, `<`, `>=`, `<=`, `==`, `!=` : 대소 관계를 비교하여 참(`true`) 또는 거짓(`false`)을 반환. |
| 비트 연산자       | `&`, `^`, `\|`, `<<`, `>>`, `<<=`, `>>=`, `^=`, `&=`, `\|=` : 비트 단위로 연산 수행. |
| 논리 연산자       | `&&`, `\|\|`, `&`, `^`, `\|`, `!`, `[조건] ? [true] : [false]` : 조건을 평가하여 논리적인 참(`true`) 또는 거짓(`false`)을 반환. |

---

### **산술 연산자**

#### **특징**
- 수학에서 가장 일반적으로 사용하는 연산자.
- 사용 형태에 따라 크게 두 가지로 분류:
  - 이항 연산자 (Binary Operator): 두 개의 피연산자 사용.
  - 단항 연산자 (Unary Operator): 한 개의 피연산자 사용.

#### **적용 예제**
```java
int C;
double dC;
C = 4 + 2; // C = 6
dC = 7 * 4; // dC = 28
C = 13 % 2; // C = 1 (나머지 연산)
```

#### **산술 연산자 구문**
| 연산자 | 설명                                      |
|--------|------------------------------------------|
| `+`    | 피연산자 두 개의 합을 계산합니다.         |
| `-`    | 피연산자 두 개의 차를 계산합니다.         |
| `%`    | 나머지 연산. 두 피연산자의 나머지를 반환. |
| `+=`   | 합산 후 결과를 왼쪽 피연산자에 대입.      |
| `-=`   | 차를 계산 후 결과를 왼쪽 피연산자에 대입. |

---

### **오버플로우와 언더플로우**

#### **오버플로우 (Overflow)**
- 변수가 표현할 수 있는 최대 범위를 초과할 때 발생.
- 예시:
  ```java
  int result = 10000000 * 100000000; // int 범위 초과
  ```

#### **언더플로우 (Underflow)**
- 부동 소수점 수에서 매우 작은 값이 정확히 표현되지 않아 0으로 처리될 때 발생.
- 예시:
  ```java
  double result = 1e-300 * 1e-300; // 결과가 0에 가까움
  ```

---

### **관계 연산자**

#### **특징**
- 두 피연산자 사이의 대소나 동등 관계를 측정.
- 결과는 참(`true`) 또는 거짓(`false`)으로 반환.

#### **관계 연산자 예시**
| 연산자 | 설명                                                |
|--------|----------------------------------------------------|
| `>`    | 왼쪽 항이 크면 참(`true`), 아니면 거짓(`false`).      |
| `<`    | 오른쪽 항이 크면 참(`true`), 아니면 거짓(`false`).    |
| `>=`   | 왼쪽 항이 크거나 같으면 참(`true`), 아니면 거짓.      |
| `<=`   | 오른쪽 항이 크거나 같으면 참(`true`), 아니면 거짓.    |
| `==`   | 양쪽 항이 같으면 참(`true`), 아니면 거짓(`false`).    |
| `!=`   | 양쪽 항이 다르면 참(`true`), 아니면 거짓(`false`).    |

---

### **논리 연산자**

#### **특징**
- 두 피연산자의 논리적 관계를 정의.
- 조건문에 사용.

#### **논리 연산자 예시**
| 연산자   | 설명                                                                                     |
|----------|-----------------------------------------------------------------------------------------|
| `&&`     | 양쪽 피연산자가 모두 참(`true`)일 때만 참.                                               |
| `\|\|`     | 양쪽 피연산자 중 하나라도 참(`true`)이면 참.                                             |
| `!`      | 피연산자가 참(`true`)이면 거짓(`false`), 거짓이면 참으로 반환.                           |
| `조건식 ? true : false` | 조건식이 참일 경우 앞의 값(`true`), 거짓일 경우 뒤의 값(`false`) 반환. |

#### **예제**
```java
boolean result;
result = (3 > 2) && (4 > 1); // true
result = !(3 > 5);           // true
```

---

### **비트 연산자**

#### **특징**
- 정수형 피연산자를 대상으로 비트 단위 연산 수행.

#### **비트 연산자 예시**
| 연산자 | 설명                                                            |
|--------|----------------------------------------------------------------|
| `&`    | 비트 AND 연산. 두 비트가 모두 1일 때 1 반환.                     |
| `\|`    | 비트 OR 연산. 하나라도 1이면 1 반환.                            |
| `^`    | 비트 XOR 연산. 두 비트가 다르면 1 반환.                          |
| `<<`   | 왼쪽으로 비트를 이동하며 빈 자리는 0으로 채움.                   |
| `>>`   | 오른쪽으로 비트를 이동하며 빈 자리는 부호 비트로 채움.           |

#### **예제**
```java
int x = 6; // 110 in binary
int y = 3; // 011 in binary
int result;
result = x & y; // 010 in binary, result = 2
result = x | y; // 111 in binary, result = 7
```

---

### **연산자 우선순위**

| 우선순위 | 연산자                             | 설명                                                      |
|----------|------------------------------------|----------------------------------------------------------|
| 1        | `.`, `[]`, `()`                   | 멤버 접근, 배열 인덱스, 함수 호출 연산자.                |
| 2        | `!`, `~`, `+/-`, `++/--`, `(cast)` | 논리 부정, 비트 NOT, 단항 부호 연산, 전위 증감, 형변환.  |
| 3        | `+`, `-`, `*`, `/`, `%`           | 산술 연산자.                                              |
| 4        | `<<`, `>>`, `>>>`                 | 비트 이동 연산자.                                         |
| 5        | `<`, `>`, `<=`, `>=`, `==`, `!=`  | 관계 연산자.                                              |
| 6        | `&`, `^`, `\|`                     | 비트 논리 연산자.                                         |
| 7        | `&&`, `\|\|`                        | 논리 AND, 논리 OR 연산자.                                 |
| 8        | `[조건항] ? [true] : [false]`     | 조건 연산자.                                              |
| 9        | `=`, `+=`, `-=`, `*=`, `/=`, `%=` | 할당 및 복합 할당 연산자.                                 |
| 10       | `++/--` (후위형 증감 연산자)      | 후위 증감 연산자.                                         |

---

### **자바 참조형 타입**

#### **특징**
- 클래스(Class), 인터페이스(Interface), 배열(Array), 열거(Enum)으로 구성.
- 기본형 타입과 달리 빈 객체를 나타내는 `null` 값을 가질 수 있습니다.

#### **메모리 크기와 기본값**
| 구분         | 메모리 크기 | 기본값 |
|--------------|-------------|--------|
| 클래스       | 4바이트     | `null` |
| 인터페이스   | 4바이트     | `null` |
| 배열         | 4바이트     | `null` |
| 열거         | 4바이트     | `null` |

---

### **문자열 (String)**

#### **문자열 선언과 생성**
- 문자열 리터럴은 내부적으로 `new String()`을 호출해 객체를 생성합니다.
- 같은 내용의 문자열 리터럴은 동일한 String 객체를 공유합니다.

#### **예제**
```java
String s1 = "Hello"; // 문자열 리터럴로 생성
String s2 = new String("Hello"); // 명시적으로 생성
System.out.println(s1 == s2); // false: 다른 객체 비교
System.out.println(s1.equals(s2)); // true: 내용 비교
```

#### **문자열 비교 메서드**
| 메서드                            | 설명                                    |
|-----------------------------------|-----------------------------------------|
| `int compareTo(String s)`         | 사전 순으로 문자열 비교.                |
| `int compareToIgnoreCase(String)` | 대소문자 구분 없이 사전 순으로 비교.    |
| `boolean equals(String s)`        | 문자열 내용이 같은지 비교.              |
| `boolean equalsIgnoreCase(String)`| 문자열 내용이 대소문자 구분 없이 같은지 비교. |

#### **문자열 조작 메서드**
| 메서드                            | 설명                                    |
|-----------------------------------|-----------------------------------------|
| `char charAt(int index)`          | index가 지정한 문자를 반환                |
| `String concat(String s)`         | 주어진 문자열 s를 현재 문자열 뒤에 연결    |
| `boolean contains(String s)`      | 문자열 s를 포함하는지 조사                |
| `boolean endsWith(String s)`      | 끝나는 문자열이 s인지 조사                |
| `int indexOf(String s)`           | 문자열 s가 나타난 위치를 반환               |
| `boolean isBlank()`               | 길이가 0 혹은 공백 있으면 true 반환 (자바 11부터) |
| `boolean isEmpty()`               | 길이가 0이면 true 반환                    |
| `int length()`                    | 길이를 반환                               |
| `String repeat(int c)`            | index부터 시작하는 문자열의 일부를 반환     |
| `boolean startsWith(String s)`    | 시작하는 문자열이 s인지 조사                |
| `String substring(int index)`     | index부터 시작하는 문자열의 일부를 반환     |
| `String toLowerCase()`            | 모두 소문자로 변환                          |
| `String toUpperCase()`            | 모두 대문자로 변환                         |
| `String trim()`                   | 앞뒤에 있는 공백을 제거한 후 반환 |

#### **유용한 정적 메서드**
| 메서드               | 설명                                      |
|----------------------|-------------------------------------------|
| `String format()`    | 지정된 형식에 맞춰 문자열 반환.           |
| `String join()`      | 지정된 구분자로 여러 문자열 연결.         |
| `String valueOf()`   | 기본 타입 값을 문자열로 변환.              |

---

### **배열 (Array)**

#### **배열이란?**
- 동일한 데이터 타입을 연속적으로 저장하는 자료구조.
- 고정된 크기를 가지며, 크기는 배열 생성 시 결정됩니다.

#### **배열의 선언과 생성**
```java
int[] numbers; // 선언
numbers = new int[5]; // 생성

// 선언과 동시에 초기화
int[] scores = {90, 85, 78, 92, 88};
```

#### **배열 원소 접근**
- 배열의 인덱스는 0부터 시작합니다.
```java
int[] scores = {90, 85, 78};
System.out.println(scores[0]); // 90 출력
scores[1] = 88; // 두 번째 값을 변경
```

#### **배열 크기**
- 배열의 크기는 `.length` 속성을 통해 확인할 수 있습니다.
```java
int[] scores = {90, 85, 78};
System.out.println(scores.length); // 3 출력
```

#### **다차원 배열**
- 배열의 배열을 나타냅니다.
```java
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
System.out.println(matrix[1][2]); // 6 출력
```

---

### **동적 배열 (ArrayList)**

#### **특징**
- 자바의 `ArrayList` 클래스는 크기가 고정된 배열의 단점을 보완하여 동적으로 크기를 조정할 수 있습니다.
- 내부적으로 배열을 사용하지만, 크기를 자동으로 조절하면서 요소를 추가하거나 제거할 수 있습니다.

#### **장점**
- 요소의 추가 및 삭제가 용이.
- 크기 제한이 없으며, 필요에 따라 크기를 자동으로 조절.
- 다양한 메서드(`add`, `remove`, `get`, `set`, `size` 등)를 제공하여 배열보다 사용이 간편.

#### **예제 코드**
```java
import java.util.ArrayList;

public class DynamicArrayExample {
    public static void main(String[] args) {
        // ArrayList 생성
        ArrayList<String> fruits = new ArrayList<>();
        
        // 요소 추가
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");
        
        // 요소 출력
        System.out.println("Fruits: " + fruits);

        // 요소 삭제
        fruits.remove("Banana");
        System.out.println("After removal: " + fruits);

        // 요소 접근
        System.out.println("First fruit: " + fruits.get(0));

        // 리스트 크기 확인
        System.out.println("Size: " + fruits.size());
    }
}
```

#### **Array와의 차이점**
| Feature         | Array                | ArrayList                 |
|------------------|----------------------|---------------------------|
| 크기             | 고정                | 동적으로 조절 가능         |
| 데이터 타입       | 기본형, 참조형 모두 사용 가능 | 참조형만 저장 가능          |
| 메서드 지원 여부  | 직접 구현 필요       | 다양한 메서드 제공          |

---

### **열거 타입 (Enum)**

#### **필요성**
- 제한된 경우의 수를 상수로 표현.
- 열거 타입은 코드의 가독성을 높이고, 컴파일러에 의해 타입 안정성을 제공합니다.

#### **열거 타입 선언 및 사용 예제**
```java
public enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

public class EnumExample {
    public static void main(String[] args) {
        Day today = Day.MONDAY;
        switch (today) {
            case MONDAY:
                System.out.println("Start of the week!");
                break;
            case FRIDAY:
                System.out.println("Almost weekend!");
                break;
            default:
                System.out.println("Midweek day!");
        }
    }
}
```

#### **열거 타입과 메서드**
열거 타입은 메서드, 필드, 생성자를 가질 수 있습니다.

```java
public enum TrafficLight {
    RED("Stop"), 
    YELLOW("Caution"), 
    GREEN("Go");

    private final String action;

    // 생성자
    TrafficLight(String action) {
        this.action = action;
    }

    // 메서드
    public String getAction() {
        return action;
    }
}

public class EnumWithMethodExample {
    public static void main(String[] args) {
        TrafficLight light = TrafficLight.RED;
        System.out.println(light + ": " + light.getAction()); // RED: Stop
    }
}
```

#### **장점**
1. **타입 안정성**: 열거 타입 상수 외의 값은 사용할 수 없습니다.
2. **코드 가독성**: 의미 있는 이름으로 상수를 정의.
3. **강력한 기능**: 열거 타입 내에 메서드나 필드 추가 가능.

#### **Switch 문과 Enum**
열거 타입은 `switch` 문과 함께 사용할 수 있습니다.
```java
public enum Level {
    LOW, MEDIUM, HIGH
}

public class EnumSwitchExample {
    public static void main(String[] args) {
        Level myLevel = Level.HIGH;

        switch (myLevel) {
            case LOW:
                System.out.println("Low level");
                break;
            case MEDIUM:
                System.out.println("Medium level");
                break;
            case HIGH:
                System.out.println("High level");
                break;
        }
    }
}
```

---

## **Chap 4. 제어문의 종류**

---

### **제어문의 개요**

#### **역할**
- 자바 프로그램이 원하는 결과를 얻기 위해서는 순차적인 흐름을 제어해야 하는 경우가 많습니다.
- 제어문은 프로그램의 흐름을 조건에 따라 선택하거나 반복을 실행하는 데 사용됩니다.

#### **제어문의 종류**
- **조건문**: `if`, `if/else`, `if/else if/else`, 삼항 연산자, `switch`
- **반복문**: `while`, `do/while`, `for`, **향상된 for문 (Enhanced for)**
- **기타 제어문**: `continue`, `break`

---

### **조건문**

#### **if 문**
- 조건이 참일 때만 실행되는 명령문입니다.

```java
if (조건식) {
    // 조건이 참일 때 실행되는 코드
}
```

**예제**:
```java
int num = 10;
if (num > 5) {
    System.out.println("num은 5보다 큽니다.");
}
```

#### **if/else 문**
- 조건에 따라 두 가지 경우 중 하나를 선택합니다.

```java
if (조건식) {
    // 조건이 참일 때 실행되는 코드
} else {
    // 조건이 거짓일 때 실행되는 코드
}
```

**예제**:
```java
int num = 3;
if (num > 5) {
    System.out.println("num은 5보다 큽니다.");
} else {
    System.out.println("num은 5보다 작거나 같습니다.");
}
```

#### **if/else if/else 문**
- 여러 조건 중 하나를 선택합니다.

```java
if (조건식1) {
    // 조건식1이 참일 때 실행
} else if (조건식2) {
    // 조건식2가 참일 때 실행
} else {
    // 모든 조건이 거짓일 때 실행
}
```

**예제**:
```java
int score = 85;
if (score >= 90) {
    System.out.println("A grade");
} else if (score >= 80) {
    System.out.println("B grade");
} else {
    System.out.println("C grade");
}
```

#### **switch 문**
- 변수의 값에 따라 여러 경우 중 하나를 선택합니다.

```java
switch (변수) {
    case 값1:
        // 값1일 때 실행
        break;
    case 값2:
        // 값2일 때 실행
        break;
    default:
        // 모든 case가 아닐 때 실행
}
```

**예제**:
```java
int day = 2;
switch (day) {
    case 1:
        System.out.println("Monday");
        break;
    case 2:
        System.out.println("Tuesday");
        break;
    default:
        System.out.println("Other day");
}
```

---

### **반복문**

#### **while 문**
- 조건이 참인 동안 코드를 반복 실행합니다.

```java
while (조건식) {
    // 반복 실행할 코드
}
```

**예제**:
```java
int i = 1;
while (i <= 5) {
    System.out.println("i = " + i);
    i++;
}
```

#### **do/while 문**
- 코드 블록을 먼저 실행한 후 조건을 검사합니다.

```java
do {
    // 반복 실행할 코드
} while (조건식);
```

**예제**:
```java
int i = 1;
do {
    System.out.println("i = " + i);
    i++;
} while (i <= 5);
```

#### **for 문**
- 초기값, 조건식, 증감식을 이용하여 반복합니다.

```java
for (초기값; 조건식; 증감식) {
    // 반복 실행할 코드
}
```

**예제**:
```java
for (int i = 1; i <= 5; i++) {
    System.out.println("i = " + i);
}
```

#### **Enhanced for 문 (향상된 for문)**
- 배열이나 컬렉션의 모든 요소를 순회할 때 사용합니다.

```java
for (데이터타입 변수 : 배열) {
    // 반복 실행할 코드
}
```

**예제**:
```java
int[] numbers = {1, 2, 3, 4, 5};
for (int num : numbers) {
    System.out.println(num);
}
```

---

### **기타 제어문**

#### **break 문**
- 반복문을 즉시 종료합니다.

**예제**:
```java
for (int i = 1; i <= 5; i++) {
    if (i == 3) {
        break; // 반복문 종료
    }
    System.out.println("i = " + i);
}
```

#### **continue 문**
- 현재 반복을 건너뛰고 다음 반복으로 이동합니다.

**예제**:
```java
for (int i = 1; i <= 5; i++) {
    if (i == 3) {
        continue; // 이후 코드 생략하고 다음 반복으로 이동
    }
    System.out.println("i = " + i);
}
```

---

## **Chap 5. 객체지향 기초**

---

### **객체지향 프로그래밍 (OOP)**

#### **객체(Object)란?**
- 소프트웨어 객체는 현실 세계의 객체를 모델링한 것으로, **상태**와 **동작**으로 구성됩니다.
- **상태**는 객체의 속성을 나타내며, 자바에서는 **필드(Field)**로 표현됩니다.
- **동작**은 객체가 수행할 수 있는 작업을 의미하며, 자바에서는 **메서드(Method)**로 표현됩니다.

#### **예제 코드: 객체의 속성과 동작**
```java
class Car {
    // 필드
    String color;
    int speed;

    // 메서드
    void drive() {
        System.out.println("The car is driving.");
    }

    void stop() {
        System.out.println("The car has stopped.");
    }
}

public class ObjectExample {
    public static void main(String[] args) {
        Car myCar = new Car(); // 객체 생성
        myCar.color = "Red"; // 필드 값 설정
        myCar.speed = 100;

        System.out.println("Car color: " + myCar.color);
        System.out.println("Car speed: " + myCar.speed);
        myCar.drive();
        myCar.stop();
    }
}
```

---

### **절차 지향 프로그래밍 (POP)**

#### **특징**
- 동작을 순서에 맞추어 실행하도록 명령어를 나열합니다.
- 데이터를 정의하는 방식보다는 명령어의 순서와 흐름에 중점을 둡니다.
- 간단한 프로그램에서는 이해하고 구현하기 용이하지만, 규모가 커질수록 복잡도가 증가합니다.

---

### **객체지향 프로그래밍 (OOP)**

#### **특징**
1. **캡슐화 (Encapsulation)**
   - 객체의 데이터와 메서드를 하나의 단위로 묶고, 외부에서는 필요한 부분만 접근할 수 있도록 제한합니다.
   - **장점**: 데이터 은닉으로 보안성 향상, 코드 유지보수 용이.

   **예제**:
   ```java
   class Person {
       private String name;
       private int age;

       // Getter와 Setter
       public String getName() {
           return name;
       }

       public void setName(String name) {
           this.name = name;
       }

       public int getAge() {
           return age;
       }

       public void setAge(int age) {
           this.age = age;
       }
   }
   
   public class EncapsulationExample {
       public static void main(String[] args) {
           Person person = new Person();
           person.setName("Alice");
           person.setAge(25);
           System.out.println("Name: " + person.getName());
           System.out.println("Age: " + person.getAge());
       }
   }
   ```

2. **상속 (Inheritance)**
   - 기존 클래스(부모 클래스)의 필드와 메서드를 새로운 클래스(자식 클래스)가 물려받아 사용할 수 있습니다.
   - **장점**: 코드 재사용성 증가, 유지보수 용이.

   **예제**:
   ```java
   class Animal {
       void eat() {
           System.out.println("This animal eats food.");
       }
   }

   class Dog extends Animal {
       void bark() {
           System.out.println("The dog barks.");
       }
   }

   public class InheritanceExample {
       public static void main(String[] args) {
           Dog dog = new Dog();
           dog.eat(); // 부모 클래스의 메서드 사용
           dog.bark(); // 자식 클래스의 메서드 사용
       }
   }
   ```

3. **다형성 (Polymorphism)**
   - 동일한 메서드 이름으로 다양한 동작을 수행할 수 있습니다.
   - **장점**: 코드 유연성 증가.

   **예제**:
   ```java
   class Shape {
       void draw() {
           System.out.println("Drawing a shape.");
       }
   }

   class Circle extends Shape {
       @Override
       void draw() {
           System.out.println("Drawing a circle.");
       }
   }

   class Rectangle extends Shape {
       @Override
       void draw() {
           System.out.println("Drawing a rectangle.");
       }
   }

   public class PolymorphismExample {
       public static void main(String[] args) {
           Shape shape;

           shape = new Circle();
           shape.draw();

           shape = new Rectangle();
           shape.draw();
       }
   }
   ```

4. **추상화 (Abstraction)**
   - 불필요한 세부사항을 제거하고 중요한 정보만 남기는 과정.
   - 현실 세계의 객체를 클래스와 메서드로 모델링.

   **예제**:
   ```java
   abstract class Vehicle {
       abstract void start();
       abstract void stop();
   }

   class Car extends Vehicle {
       @Override
       void start() {
           System.out.println("Car is starting.");
       }

       @Override
       void stop() {
           System.out.println("Car has stopped.");
       }
   }

   public class AbstractionExample {
       public static void main(String[] args) {
           Vehicle myCar = new Car();
           myCar.start();
           myCar.stop();
       }
   }
   ```

---

### **클래스 선언**

#### **클래스란?**
- 클래스는 객체를 생성하기 위한 청사진(템플릿)입니다.
- 클래스는 필드(데이터)와 메서드(동작)로 구성됩니다.

#### **클래스 선언 형식**
```java
class 클래스이름 {
    // 필드
    데이터타입 변수명;

    // 메서드
    반환타입 메서드이름() {
        // 실행 코드
    }
}
```

#### **클래스 선언 예제**
```java
class Car {
    String color;
    int speed;

    void drive() {
        System.out.println("The car is driving.");
    }

    void stop() {
        System.out.println("The car has stopped.");
    }
}
```

#### **클래스와 파일 구조**
- 한 파일에는 여러 클래스를 선언할 수 있지만, `public` 클래스를 하나만 선언할 수 있습니다.
- `public` 클래스의 이름은 파일 이름과 동일해야 합니다.

**예제:**
- 파일 이름: `Car.java`
```java
public class Car {
    String color;
    int speed;
}

class Engine {
    int horsepower;
}
```

---

### **객체 생성과 참조 변수**

#### **객체 생성과 참조 변수란?**
- **객체 생성**: 클래스의 인스턴스를 메모리에 할당합니다.
- **참조 변수**: 생성된 객체를 참조하기 위해 사용하는 변수입니다.

#### **객체 생성 문법**
```java
클래스이름 객체이름 = new 클래스이름();
```

#### **예제: 객체 생성과 참조 변수**
```java
class Car {
    String color;
    int speed;
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car(); // 객체 생성
        myCar.color = "Red";
        myCar.speed = 120;

        System.out.println("Car color: " + myCar.color);
        System.out.println("Car speed: " + myCar.speed);
    }
}
```

---

### **기초 타입과 참조 타입**

#### **기초 타입**
- 기본 데이터 타입 (예: `int`, `double`, `boolean` 등)은 값을 직접 저장합니다.

#### **참조 타입**
- 클래스와 배열 등은 참조 타입이며, 값이 아닌 객체의 메모리 주소를 저장합니다.

#### **예제: 기초 타입과 참조 타입**
```java
public class Main {
    public static void main(String[] args) {
        int a = 10; // 기초 타입
        int b = a; // 값 복사
        b = 20;

        System.out.println("a: " + a); // a는 10

        Car myCar = new Car(); // 참조 타입
        Car anotherCar = myCar; // 참조 복사
        anotherCar.color = "Blue";

        System.out.println("myCar.color: " + myCar.color); // Blue
    }
}
```

---

### **클래스의 구성 요소와 멤버 접근**

#### **클래스 구성 요소**
1. **필드(Field)**: 클래스의 데이터.
2. **메서드(Method)**: 클래스의 동작.
3. **생성자(Constructor)**: 객체 초기화를 위한 특별한 메서드.

#### **필드와 지역 변수의 차이**
| 구분            | 필드                         | 지역 변수                 |
|----------------|-----------------------------|--------------------------|
| 선언 위치       | 클래스 내부                  | 메서드 내부               |
| 기본값          | 자동 초기화 (예: `0`, `null`) | 초기화하지 않으면 오류 발생 |
| 접근 범위       | 클래스 전체                  | 선언된 블록 내부에서만 사용 |

**예제:**
```java
class Example {
    int field; // 필드

    void method() {
        int localVar; // 지역 변수
        // System.out.println(localVar); // 초기화되지 않아 오류 발생
    }
}
```

---

### **접근자와 설정자 (Getter/Setter)**

#### **필요성**
- 캡슐화를 통해 필드에 직접 접근을 막고, 메서드를 통해 값을 설정하거나 가져옵니다.

#### **Getter/Setter 사용 예제**
```java
class Person {
    private String name;
    private int age;

    // Getter
    public String getName() {
        return name;
    }

    // Setter
    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person();
        person.setName("Alice");
        person.setAge(30);

        System.out.println("Name: " + person.getName());
        System.out.println("Age: " + person.getAge());
    }
}
```

---

### **생성자**

#### **생성자의 역할**
- 객체 생성 시 필드를 초기화합니다.
- 생성자는 클래스 이름과 동일하며, 반환 타입이 없습니다.

#### **예제: 생성자 선언**
```java
class Car {
    String color;
    int speed;

    // 생성자
    Car(String color, int speed) {
        this.color = color;
        this.speed = speed;
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car("Red", 120);
        System.out.println("Color: " + myCar.color);
        System.out.println("Speed: " + myCar.speed);
    }
}
```

#### **디폴트 생성자**
- 생성자를 선언하지 않으면 컴파일러가 자동으로 디폴트 생성자를 추가합니다.
- 디폴트 생성자는 매개변수가 없습니다.

#### **생성자 오버로딩**
- 같은 이름의 생성자를 매개변수의 종류나 개수로 구분합니다.

**예제:**
```java
class Car {
    String color;
    int speed;

    // 생성자 오버로딩
    Car() {
        this.color = "Unknown";
        this.speed = 0;
    }

    Car(String color, int speed) {
        this.color = color;
        this.speed = speed;
    }
}
```

#### **this와 this()**
- `this`: 현재 객체를 참조합니다.
- `this()`: 생성자 내부에서 다른 생성자를 호출합니다.

**예제:**
```java
class Car {
    String color;
    int speed;

    Car() {
        this("Unknown", 0); // 다른 생성자 호출
    }

    Car(String color, int speed) {
        this.color = color;
        this.speed = speed;
    }
}
```

#### **연속 호출**
- 메서드 체이닝(Chaining)을 통해 가독성을 높입니다.

**예제:**
```java
class Person {
    private String name;
    private int age;

    Person setName(String name) {
        this.name = name;
        return this;
    }

    Person setAge(int age) {
        this.age = age;
        return this;
    }

    void sayHello() {
        System.out.println("Hello, my name is " + name + " and I am " + age + " years old.");
    }
}

public class Main {
    public static void main(String[] args) {
        new Person().setName("John").setAge(25).sayHello();
    }
}
```

---

### **정적 멤버란?**

- 자바에서는 `static` 키워드를 사용하여 클래스의 필드와 메서드를 모든 인스턴스에서 공유할 수 있도록 합니다.
- **정적 변수 (클래스 변수)**: 클래스에 한 번만 생성되며, 모든 객체가 공유합니다.
- **인스턴스 변수**: 각 객체에 독립적으로 존재하며, 객체가 생성될 때마다 초기화됩니다.

---

### **정적 변수와 정적 메서드의 특징**

#### **정적 변수**
- 모든 객체가 동일한 값을 공유합니다.
- 클래스가 메모리에 로드될 때 생성되며 프로그램이 종료될 때 소멸됩니다.
- 객체를 생성하지 않고도 클래스 이름으로 접근 가능합니다.

```java
class Counter {
    static int count = 0; // 정적 변수

    Counter() {
        count++;
    }
}

public class Main {
    public static void main(String[] args) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();

        System.out.println("Count: " + Counter.count); // Count: 2
    }
}
```

#### **정적 메서드**
- 객체 생성 없이 호출할 수 있는 메서드.
- 클래스의 상태(정적 변수)에만 접근할 수 있으며, 인스턴스 변수나 메서드에는 접근할 수 없습니다.
- `this` 키워드를 사용할 수 없습니다.

```java
class Calculator {
    static int add(int a, int b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        int result = Calculator.add(5, 3); // 정적 메서드 호출
        System.out.println("Result: " + result); // Result: 8
    }
}
```

---

### **정적 멤버 활용**

#### **정적 변수의 활용**
- 클래스 전체에서 공통적으로 사용되는 데이터를 저장하는 데 유용합니다.

```java
class Config {
    static String appName = "My Application";
    static String version = "1.0.0";
}

public class Main {
    public static void main(String[] args) {
        System.out.println("App Name: " + Config.appName);
        System.out.println("Version: " + Config.version);
    }
}
```

#### **정적 메서드의 활용**
- 유틸리티 메서드와 같이 객체 상태와 무관한 작업을 처리할 때 유용합니다.

```java
class MathUtil {
    static int square(int number) {
        return number * number;
    }
}

public class Main {
    public static void main(String[] args) {
        int square = MathUtil.square(5); // 정적 메서드 호출
        System.out.println("Square: " + square); // Square: 25
    }
}
```

---

### **주의점**
1. **인스턴스 변수와 정적 변수의 구분**
   - 정적 변수는 클래스 차원에서 공유되며 모든 객체에 영향을 미칩니다.
   - 인스턴스 변수는 각 객체마다 독립적으로 존재합니다.

2. **정적 메서드는 인스턴스 변수에 접근할 수 없음**
   - 정적 메서드는 객체가 아닌 클래스에 속하기 때문에 인스턴스 변수와 메서드에는 접근할 수 없습니다.

```java
class Example {
    int instanceVar = 10;
    static int staticVar = 20;

    static void show() {
        // System.out.println(instanceVar); // 오류 발생
        System.out.println(staticVar); // 정적 변수 접근 가능
    }
}
```

3. **메모리 관리**
   - 정적 변수는 프로그램이 종료될 때까지 메모리에 남아 있으므로, 불필요한 데이터는 삭제해야 메모리 누수를 방지할 수 있습니다.

---

## **Chap 6. 상속**

### **상속이란**
#### **필요성**
상속은 기존의 클래스를 재사용하여 새로운 클래스를 만드는 기능으로, 코드의 재사용성과 확장성을 높여줍니다.

#### **상속과 클래스 멤버**
- 자식 클래스는 부모 클래스에서 물려받은 멤버를 그대로 사용하거나 변경할 수 있으며, 새로운 멤버를 추가할 수도 있습니다.
- 따라서 자식 클래스는 대체로 부모 클래스보다 더 많은 속성이나 동작을 가집니다.

##### **상속과 클래스 멤버 예제**
```java
class Parent {
    String name = "Parent";

    void display() {
        System.out.println("This is the parent class.");
    }
}

class Child extends Parent {
    int age = 10;

    @Override
    void display() {
        System.out.println("This is the child class.");
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        System.out.println("Name: " + child.name);
        System.out.println("Age: " + child.age);
        child.display();
    }
}
```

---

### **클래스 상속**
#### **부모·자식 클래스의 관계**
- 상속은 **is-a 관계**를 나타냅니다.
- 만약 **has-a 관계**라면 상속보다는 객체 포함(Composition)을 사용하는 것이 적합합니다.

##### **부모·자식 클래스의 관계 예제**
```java
class Vehicle {
    void move() {
        System.out.println("Vehicle is moving");
    }
}

class Car extends Vehicle {
    void fuel() {
        System.out.println("Car is refueling");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.move();  // 부모 클래스의 메서드
        car.fuel();  // 자식 클래스의 메서드
    }
}
```

#### **상속의 선언**
- **`extends` 키워드**를 사용하여 상속을 선언합니다.
- Java에서는 **다중 상속**을 허용하지 않습니다.

##### **상속의 선언 예제**
```java
class Parent {
    void sayHello() {
        System.out.println("Hello from Parent");
    }
}

class Child extends Parent {
    void sayHello() {
        System.out.println("Hello from Child");
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.sayHello();
    }
}
```

#### **현실 세계와 상속 적용**
- 객체 지향의 상속을 적용할 수 있는 현실 세계의 예:
  - `Animal` 클래스와 이를 상속받는 `Eagle`, `Tiger`, `Goldfish`.
  - `Bike` 클래스와 이를 상속받는 `MountainBike`, `RoadBike`, `TandemBike`.

##### **현실 세계와 상속 적용 예제**
```java
class Animal {
    void eat() {
        System.out.println("This animal eats food");
    }
}

class Tiger extends Animal {
    @Override
    void eat() {
        System.out.println("The tiger hunts for food");
    }
}

public class Main {
    public static void main(String[] args) {
        Tiger tiger = new Tiger();
        tiger.eat();
    }
}
```

---

### **부모 클래스와 자식 클래스**
| **부모 클래스** | **자식 클래스**                    |
|------------------|------------------------------------|
| Animal           | Eagle, Tiger, Goldfish            |
| Bike             | MountainBike, RoadBike, TandemBike|
| Circle           | Ball, Cone, Cylinder              |
| Drinks           | Beer, Coke, Juice, Wine           |

---

### **메서드 오버라이딩**
#### **의미**
- **메서드 오버라이딩(Method Overriding)**은 부모 클래스에서 물려받은 메서드를 자식 클래스에서 재정의하는 것을 의미합니다.
- 예: 넓이를 구하는 `findArea()` 메서드.

#### **규칙**
- 부모 클래스의 메서드와 **동일한 시그너처**를 사용해야 합니다.
- 부모 클래스의 메서드보다 접근 범위를 **좁게 수정**할 수 없습니다.
- 새로운 예외(Exception)를 추가로 선언할 수 없습니다.

#### **오버라이딩 불가**
- **`private` 메서드**: 부모 클래스 전용이므로 상속되지 않습니다.
- **정적 메서드**: 클래스 소속이므로 상속되지 않습니다.
- **`final` 메서드**: 더 이상 수정할 수 없으므로 오버라이딩이 불가능합니다.

##### **메서드 오버라이딩 예제**
```java
class Parent {
    void show() {
        System.out.println("This is a method in Parent");
    }
}

class Child extends Parent {
    @Override
    void show() {
        System.out.println("This is a method in Child");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Child();
        obj.show();  // 자식 클래스의 show() 메서드 호출
    }
}
```

#### **부모 클래스의 멤버 접근**
- 자식 클래스가 메서드를 오버라이딩하면, 부모 클래스의 메서드는 자식 객체에서 숨겨집니다.
- 숨겨진 메서드를 호출하려면 **`super` 키워드**를 사용해야 합니다.

##### **부모 클래스의 멤버 접근 예제**
```java
class Parent {
    void display() {
        System.out.println("Parent's display method");
    }
}

class Child extends Parent {
    @Override
    void display() {
        super.display();
        System.out.println("Child's display method");
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.display();
    }
}
```

#### **메서드 오버라이딩과 메서드 오버로딩**
| **비교 요소**   | **메서드 오버라이딩** | **메서드 오버로딩** |
|------------------|-----------------------|---------------------|
| 메서드 이름       | 동일                  | 동일                |
| 매개변수          | 동일                  | 다름                |

##### **메서드 오버라이딩과 메서드 오버로딩 예제**
```java
// 메서드 오버라이딩
class Parent {
    void greet() {
        System.out.println("Hello from Parent");
    }
}

class Child extends Parent {
    @Override
    void greet() {
        System.out.println("Hello from Child");
    }
}

// 메서드 오버로딩
class OverloadExample {
    void greet() {
        System.out.println("Hello");
    }

    void greet(String name) {
        System.out.println("Hello, " + name);
    }
}

public class Main {
    public static void main(String[] args) {
        // 오버라이딩 예제
        Parent obj = new Child();
        obj.greet();

        // 오버로딩 예제
        OverloadExample example = new OverloadExample();
        example.greet();
        example.greet("John");
    }
}
```

### **패키지**
#### **의미**
- 클래스 파일을 묶어서 관리하기 위한 수단으로 파일 시스템의 폴더를 이용합니다.

#### **패키지에 의한 장점**
- 패키지마다 별도의 이름 공간(Namespace)이 생기기 때문에 클래스 이름의 유일성을 보장합니다.
- 클래스를 패키지 단위로 제어할 수 있어 좀 더 세밀하게 접근을 제어할 수 있습니다.

#### **대표적인 패키지**
- **`java.lang` 패키지**: import 문 없이 자동으로 임포트되며, 기본 클래스를 모아둔 패키지입니다.
- **`java.awt` 패키지**: 그래픽 프로그래밍에 관련된 클래스를 모아둔 패키지입니다.
- **`java.io` 패키지**: 입출력과 관련된 클래스를 모아둔 패키지입니다.

#### **패키지 선언**
- 주석문을 제외하고 반드시 **첫 라인**에 위치합니다.
- 패키지 이름은 모두 소문자로 명명하는 것이 관례이며, 중복 방지를 위해 회사의 도메인 이름을 역순으로 사용하는 경우가 많습니다.

#### **패키지의 사용**
- 다른 패키지에 있는 공개된 클래스를 사용하려면 패키지 경로를 컴파일러에게 알려줘야 합니다.

#### **import 문**
- 패키지의 경로를 미리 컴파일러에게 알려주는 문장입니다.
- `import` 문은 소스 파일에서 `package` 문과 첫 번째 클래스 선언부 사이에 위치합니다.

##### **import 문 예제**
```java
package com.chap07.sub01;

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter your name: ");
        String name = scanner.nextLine();
        System.out.println("Hello, " + name);
    }
}
```

---

### **자식 클래스와 부모 생성자**
#### **특징**
- 자식 생성자를 호출하면 부모 생성자도 자동으로 호출됩니다.
- 자식 생성자에는 첫 행에 부모 생성자 호출 코드가 포함되어 있습니다.

##### **자식 클래스와 부모 생성자 예제**
```java
class Parent {
    Parent() {
        System.out.println("Parent constructor called");
    }
}

class Child extends Parent {
    Child() {
        super(); // 부모 생성자 호출
        System.out.println("Child constructor called");
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
    }
}
```

---

### **상속과 접근 제어**
#### **접근 지정자의 접근 범위**
| **접근 지정자** | **동일 클래스** | **동일 패키지** | **자식 클래스** | **다른 패키지** |
|------------------|-----------------|----------------|----------------|----------------|
| public           | O               | O              | O              | O              |
| protected        | O               | O              | O              | X              |
| 없음             | O               | O              | X              | X              |
| private          | O               | X              | X              | X              |

#### **접근 지정자 사용 시 주의 사항**
- **`private` 멤버**는 자식 클래스에 상속되지 않습니다.
- 클래스 멤버는 어떤 접근 지정자로도 지정할 수 있지만, **클래스 자체**는 `protected`와 `private`으로 지정할 수 없습니다.
- 메서드를 오버라이딩할 때 부모 클래스의 메서드보다 가시성을 더 좁게 설정할 수 없습니다.

##### **접근 지정자 예제**
```java
class Parent {
    protected void show() {
        System.out.println("Parent method");
    }
}

class Child extends Parent {
    @Override
    public void show() {
        System.out.println("Child method");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent obj = new Child();
        obj.show(); // Child method
    }
}
```

---

### **Final 클래스와 메서드**
#### **final 클래스**
- **상속될 수 없는 클래스**로 정의됩니다.
- 대표적인 예: `String` 클래스.

#### **final 메서드**
- 특정 메서드를 오버라이딩하지 못하도록 선언하는 데 사용됩니다.

##### **final 클래스와 메서드 예제**
```java
final class FinalClass {
    void display() {
        System.out.println("This is a final class");
    }
}

class Parent {
    final void show() {
        System.out.println("This is a final method");
    }
}

class Child extends Parent {
    // void show() {}  // 컴파일 에러: final 메서드는 오버라이딩 불가
}

public class Main {
    public static void main(String[] args) {
        FinalClass obj = new FinalClass();
        obj.display();
    }
}
```

---

### **타입 변환과 다형성**
#### **객체의 타입 변환**
- 참조 타입 데이터도 기초 타입 데이터처럼 타입 변환이 가능합니다.
- **상속 관계**일 경우에만 타입 변환이 가능합니다.
- 기초 타입처럼 **자동 타입 변환**과 **강제 타입 변환**이 있습니다.

##### **타입 변환 예시를 위한 샘플 클래스**
```java
class Parent {
    void display() {
        System.out.println("Parent display method");
    }
}

class Child extends Parent {
    @Override
    void display() {
        System.out.println("Child display method");
    }
}
```

#### **자동 타입 변환**
- 부모 클래스 참조 변수에 자식 클래스 객체를 할당할 수 있습니다.

##### **자동 타입 변환 예제**
```java
public class Main {
    public static void main(String[] args) {
        Parent obj = new Child();
        obj.display(); // Child display method
    }
}
```

#### **강제 타입 변환**
- 부모 클래스의 참조 변수를 자식 클래스 타입으로 변환할 수 있습니다.
- 강제 타입 변환은 명시적으로 캐스팅해야 하며, 잘못된 변환은 **`ClassCastException`**을 발생시킬 수 있습니다.

##### **강제 타입 변환 예제**
```java
public class Main {
    public static void main(String[] args) {
        Parent obj = new Child();
        Child child = (Child) obj; // 강제 타입 변환
        child.display(); // Child display method
    }
}
```

#### **타입 변환을 이용한 다형성**
- 타입 변환을 통해 부모 클래스 타입의 참조 변수를 사용하여 여러 자식 클래스 객체를 다룰 수 있습니다.

##### **타입 변환을 이용한 다형성 예제**
```java
class Animal {
    void sound() {
        System.out.println("Some generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Woof");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Meow");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        Animal cat = new Cat();

        dog.sound(); // Woof
        cat.sound(); // Meow
    }
}
```

## **Chap 7. 추상화**

***

### **추상 클래스**
#### **추상 메서드**
- 메서드 본체를 완성하지 못한 메서드로, **무엇을 할지 선언**은 하지만, **어떻게 할지는 정의하지 않는** 메서드입니다.
- 예: `Shape` 클래스의 `draw()` 메서드.

#### **추상 클래스**
- 보통 하나 이상의 추상 메서드를 포함하지만, **추상 메서드가 없어도 추상 클래스**일 수 있습니다.
- 주로 **상속 계층에서 자식 멤버의 이름을 통일**하기 위해 사용됩니다.

##### **추상 클래스 선언**
```java
abstract class Shape {
    abstract void draw();
}
```

##### **추상 메서드 선언**
- 추상 클래스 내에 선언되며, 구현부가 없습니다.

##### **추상 클래스 예제**
```java
abstract class Shape {
    abstract void draw();
}

class Circle extends Shape {
    @Override
    void draw() {
        System.out.println("Drawing Circle");
    }
}

public class Main {
    public static void main(String[] args) {
        Shape shape = new Circle();
        shape.draw(); // Drawing Circle
    }
}
```

---

### **인터페이스 기초**
#### **인터페이스 의미**
##### **현실 세계의 인터페이스**
- 인터페이스는 다른 시스템 간의 연결 규약 또는 약속을 의미합니다.

##### **자바의 인터페이스**
- 클래스와 비슷하지만, **구현이 없는 메서드**만 선언할 수 있습니다.

#### **인터페이스에 의한 장점**
- **인터페이스만 준수하면** 통합에 신경 쓰지 않고 다양한 형태로 새로운 클래스를 개발할 수 있습니다.
- 클래스의 다중 상속은 지원하지 않지만, **인터페이스로 다중 상속 효과**를 간접적으로 얻을 수 있습니다.

#### **인터페이스 vs. 추상 클래스**
| **분류**             | **인터페이스**                                      | **추상 클래스**                         |
|----------------------|---------------------------------------------------|-----------------------------------------|
| 구현 메서드           | 포함 불가 (단, 디폴트 메서드와 정적 메서드는 예외) | 포함 가능                                |
| 인스턴스 변수         | 포함 불가능                                       | 포함 가능                                |
| 다중 상속             | 가능                                              | 불가능                                   |
| 디폴트 메서드         | 선언 가능                                         | 선언 불가능                              |
| 생성자와 main()       | 선언 불가능                                       | 선언 가능                                |
| 상속에서의 부모       | 인터페이스                                        | 인터페이스, 추상 클래스                 |
| 접근 범위             | 모든 멤버를 공개                                  | 추상 메서드는 최소한 자식에게 공개해야 함 |

#### **인터페이스의 예**
- 자바가 기본적으로 제공하는 인터페이스 예:
  - `java.lang` 패키지의 `CharSequence`, `Comparable`, `Runnable` 등.
  - `java.util` 패키지의 `Collection`, `Comparator`, `List` 등.

##### **Comparable 인터페이스 예제**
```java
public interface Comparable<T> {
    int compareTo(T o);
}
```

---

### **인터페이스 구조**
#### **구조와 특징**
- 인터페이스 멤버에 명시된 `public`, `static`, `final`, `abstract` 키워드는 생략 가능합니다.
- 인터페이스 파일 확장자도 `.java`입니다.
- 컴파일하면 확장자가 `.class`인 파일을 생성합니다.

##### **인터페이스 구조 예제**
```java
interface Drawable {
    void draw(); // abstract 메서드
    default void print() {
        System.out.println("This is a default method");
    }
    static void info() {
        System.out.println("This is a static method");
    }
}

class Circle implements Drawable {
    public void draw() {
        System.out.println("Drawing Circle");
    }
}

public class Main {
    public static void main(String[] args) {
        Drawable drawable = new Circle();
        drawable.draw();
        drawable.print();
        Drawable.info();
    }
}
```

---

### **디폴트 메서드와 정적 메서드**
#### **특징**
- **디폴트 메서드**는 오버라이딩될 수 있지만, **정적 메서드**는 오버라이딩될 수 없습니다.
- 디폴트 메서드는 인스턴스 메서드이므로 **객체를 생성한 후 호출**하지만, 정적 메서드는 **인터페이스로 직접 호출**합니다.

##### **디폴트 메서드 예제**
```java
interface Greetable {
    void greet();

    default void hello() {
        System.out.println("Hello from default method");
    }
}

class Greeter implements Greetable {
    @Override
    public void greet() {
        System.out.println("Greetings!");
    }
}

public class Main {
    public static void main(String[] args) {
        Greetable greeter = new Greeter();
        greeter.greet();
        greeter.hello();
    }
}
```

---

### **인터페이스를 이용한 다중 상속 효과**
#### **다중 상속 효과**
- 여러 인터페이스를 구현함으로써 다중 상속의 장점을 얻을 수 있습니다.

##### **다중 상속 효과 예제**
```java
interface Animal {
    void eat();
}

interface Bird {
    void fly();
}

class Sparrow implements Animal, Bird {
    public void eat() {
        System.out.println("Sparrow eats grains");
    }

    public void fly() {
        System.out.println("Sparrow flies high");
    }
}

public class Main {
    public static void main(String[] args) {
        Sparrow sparrow = new Sparrow();
        sparrow.eat();
        sparrow.fly();
    }
}
```

## **Chap 7. 추상화**

### **인터페이스 응용**
#### **인터페이스의 상속과 구현 클래스**
- 전자제품에 포함되어야 하는 제어부의 요구 조건:
  - 모든 전자제품에는 **전원을 온·오프**하는 기능이 있으며, **수리 및 공장 초기화**를 할 수 있어야 합니다.
  - 전자제품 객체는 `turnOn()` 메서드, `turnOff()` 메서드로만 전원을 조절할 수 있어야 합니다.
  - 수리 및 공장 초기화 기능을 미리 구현해 놓아 필요할 때 사용할 수 있어야 합니다.
  - 수리 기능은 자식 클래스에서 오버라이딩할 수도 있습니다.

---

### **인터페이스와 다형성**
#### **인터페이스 타입**
- 인터페이스도 클래스처럼 하나의 타입이므로 변수를 **인터페이스 타입**으로 선언할 수 있습니다.
- 인터페이스의 구현 클래스는 그 인터페이스의 **자식 타입**입니다.
- 인터페이스 타입 변수가 구현 객체를 참조한다면 **강제 타입 변환**이 가능합니다.

#### **타입 변환과 다형성**
- 인터페이스를 활용하여 객체를 다룰 때 타입 변환과 다형성이 적용됩니다.

##### **타입 변환과 다형성 예제**
```java
interface RemoteControl {
    void turnOn();
    void turnOff();
}

class Television implements RemoteControl {
    @Override
    public void turnOn() {
        System.out.println("Television is turned on");
    }

    @Override
    public void turnOff() {
        System.out.println("Television is turned off");
    }
}

public class Main {
    public static void main(String[] args) {
        RemoteControl rc = new Television(); // 인터페이스 타입으로 객체 참조
        rc.turnOn();
        rc.turnOff();

        // 강제 타입 변환
        if (rc instanceof Television) {
            Television tv = (Television) rc;
            tv.turnOn();
        }
    }
}
```

### **중첩 클래스와 중첩 인터페이스**
#### **의미**
- 클래스와 인터페이스를 다른 클래스 내부에 정의하는 구조를 의미합니다.

#### **종류**
- **중첩 클래스**: Static 또는 Non-static.
- **중첩 인터페이스**: 클래스 내부에 정의된 인터페이스.

#### **중첩 클래스의 구조**
- 외부 클래스의 멤버로 정의되며, 외부 클래스와 연관된 기능을 제공합니다.

#### **컴파일 후 생성 파일**
- 중첩 클래스는 **`OuterClassName$InnerClassName.class`** 형식의 파일로 컴파일됩니다.

##### **중첩 클래스, 중첩 인터페이스 예제**
```java
class OuterClass {
    static class StaticNestedClass {
        void display() {
            System.out.println("Static Nested Class");
        }
    }

    class InnerClass {
        void display() {
            System.out.println("Inner Class");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        OuterClass.StaticNestedClass staticNested = new OuterClass.StaticNestedClass();
        staticNested.display();

        OuterClass outer = new OuterClass();
        OuterClass.InnerClass inner = outer.new InnerClass();
        inner.display();
    }
}
```

#### **외부 클래스 접근**
- 중첩 클래스는 외부 클래스의 멤버를 직접 참조할 수 있습니다.

#### **중첩 클래스의 객체 생성**
- Static 중첩 클래스는 **외부 클래스의 객체 생성 없이** 접근 가능합니다.
- Non-static 중첩 클래스는 **외부 클래스의 객체를 통해서만** 생성할 수 있습니다.

##### **외부 클래스 접근 및 중첩 클래스의 객체 생성 예제**
```java
class Outer {
    private String message = "Hello from Outer";

    class Inner {
        void displayMessage() {
            System.out.println(message);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Outer outer = new Outer();
        Outer.Inner inner = outer.new Inner();
        inner.displayMessage();
    }
}
```

---

### **익명 클래스**
#### **소개**
- **중첩 클래스의 특수한 형태**로, 이름이 없는 클래스를 정의하여 단일 사용 목적으로 코드가 간결해집니다.
- 이벤트 처리나 스레드 구현 등에서 자주 사용됩니다.

##### **익명 클래스 예제**
```java
interface Animal {
    void sound();
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Animal() {
            @Override
            public void sound() {
                System.out.println("Woof Woof");
            }
        };
        dog.sound();

        // Runnable 익명 클래스 사용
        Runnable task = new Runnable() {
            @Override
            public void run() {
                System.out.println("Task is running");
            }
        };
        new Thread(task).start();
    }
}
```

## **Chap 8. 제네릭**

### **제네릭(Generics)**
#### **정의와 종류**
- 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법.
- 데이터 타입(Data Type)을 일반화(Generalize)하는 것을 의미.
- 클래스나 메서드에서 사용할 내부 데이터 타입을 컴파일 시 미리 저장하는 방법.
- 제네릭 사용 시:
  - 클래스나 메서드 내부에 사용되는 객체의 **타입 안정성**이 향상됩니다.
  - 반환 값에 대한 타입 변환 및 타입 검사에 들어가는 비용이 절감됩니다.

#### **사용방법 및 자주 쓰는 타입**
| **제네릭 타입** | **설명**                                                                 |
|-----------------|-------------------------------------------------------------------------|
| T               | 타입(Type)을 나타냅니다. 일반적으로 클래스나 인터페이스에서 타입 매개변수로 사용됩니다. |
| E               | 요소(Element)를 나타냅니다. 주로 컬렉션에서 사용되는 항목의 타입을 지정할 때 사용됩니다. |
| K               | 키(Key)를 나타냅니다. 맵(Map) 같은 자료구조에서 키의 타입을 지정할 때 사용됩니다.     |
| V               | 값(Value)을 나타냅니다. 맵(Map)에서 값의 타입을 지정할 때 사용됩니다.                |
| N               | 숫자(Number)를 나타냅니다. 숫자 타입의 제한을 두고 싶을 때 사용됩니다.               |

#### **사용방법**
- 제네릭 타입은 **타입을 파라미터**로 가지는 클래스와 인터페이스입니다.
- 클래스 또는 인터페이스 이름 뒤에 `< >` 부호가 붙고, 사이에 **타입 파라미터**가 위치합니다.

### **제네릭 클래스**
- 클래스를 설계할 때 구체적인 타입을 명시하지 않고 **타입 파라미터**로 넣어두었다가 실제 설계한 클래스가 사용될 때 구체적인 타입을 지정합니다.
- 예: `ExClassGeneric<String> exGeneric = new ExClassGeneric<>();`
  - 이를 통해 타입 변환을 최소화할 수 있습니다.

##### **제네릭 클래스 예제 1**
```java
class Box<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}

public class Main {
    public static void main(String[] args) {
        Box<String> stringBox = new Box<>();
        stringBox.setItem("Hello Generics");
        System.out.println(stringBox.getItem());
    }
}
```

##### **제네릭 클래스 예제 2**
```java
class Pair<K, V> {
    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() {
        return key;
    }

    public V getValue() {
        return value;
    }
}

public class Main {
    public static void main(String[] args) {
        Pair<String, Integer> pair = new Pair<>("Age", 25);
        System.out.println("Key: " + pair.getKey() + ", Value: " + pair.getValue());
    }
}
```

---

### **제네릭 메소드**
- 리턴 타입을 정의하기 전에 **제네릭 타입**에 대한 정의를 반드시 명시합니다.
- 제네릭 클래스가 아닌 일반 클래스 내부에도 **제네릭 메서드**를 정의할 수 있습니다.
- 클래스에 지정된 타입 파라미터와 제네릭 메서드에 정의된 타입 파라미터는 관계가 없습니다.

##### **제네릭 메소드 예제**
```java
class Utility {
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Integer[] numbers = {1, 2, 3, 4};
        String[] words = {"Hello", "Generics"};

        Utility.printArray(numbers);
        Utility.printArray(words);
    }
}
```

---

### **제네릭 와일드 카드**
- 와일드카드 타입에는 총 세 가지의 형태가 있으며 **`?`(물음표)** 키워드로 표현됩니다.

#### **와일드카드 종류**
1. **`<?>`**: 타입 파라미터를 대치하는 것으로 모든 클래스나 인터페이스 타입 가능합니다.
2. **`<? extends 상위타입>`**: 와일드카드의 범위를 특정 객체의 **하위 클래스**만 가능하게 제한합니다.
3. **`<? super 하위타입>`**: 와일드카드의 범위를 특정 객체의 **상위 클래스**만 가능하게 제한합니다.

##### **제네릭 와일드 카드 예제**
```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void printList(List<?> list) {
        for (Object obj : list) {
            System.out.println(obj);
        }
    }

    public static void main(String[] args) {
        List<String> strings = new ArrayList<>();
        strings.add("Apple");
        strings.add("Banana");

        printList(strings);

        List<Integer> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2);

        printList(numbers);
    }
}
```
## **Chap 9. 예외**

### **예외(Exception)**
#### **정의**
- 프로그램 실행 중 예기치 못한 상황으로 인해 오류가 발생하는 것을 예외라고 합니다.
- 예외는 사용자의 잘못된 조작이나 개발자의 잘못된 코딩으로 인해 발생할 수 있습니다.
- 예외 처리 프로그램을 통해 프로그램이 **중단되지 않고 정상 실행 상태를 유지**하도록 만들 수 있습니다.

##### **예외 발생 예시**
```java
public class Main {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3};
        System.out.println(numbers[3]); // ArrayIndexOutOfBoundsException 발생
    }
}
```
위 코드에서 `numbers[3]`은 배열의 범위를 벗어나므로 예외가 발생합니다.

---

### **일반 예외 (Checked Exception)**
- 컴파일 시점에 발견되는 예외입니다.
- 반드시 예외 처리를 해야 프로그램이 실행됩니다.

#### **예외 클래스 및 설명**
| **예외 클래스**         | **설명**                                                                 |
|-------------------------|-------------------------------------------------------------------------|
| IOException            | 입력 및 출력 작업 실패 또는 인터럽트 시 발생하는 예외.                       |
| FileNotFoundException   | 파일이 없을 때 발생하는 예외.                                              |
| ParseException          | 문자열을 파싱하는 도중 문제가 발생했을 때 발생하는 예외.                   |
| ClassNotFoundException  | 요청한 클래스를 찾을 수 없을 때 발생하는 예외.                             |
| SQLException            | 데이터베이스 접근 오류나 기타 이유로 발생하는 예외.                        |
| MalformedURLException   | 잘못된 형식의 URL을 지정할 경우 발생하는 예외.                             |
| InterruptedException    | 스레드가 작업 중 인터럽트될 때 발생하는 예외.                              |
| NoSuchMethodException   | 요청한 메서드를 찾을 수 없을 때 발생하는 예외.                             |
| NoSuchFieldException    | 요청한 필드를 찾을 수 없을 때 발생하는 예외.                               |

##### **일반 예외 예제**
```java
try {
    FileReader reader = new FileReader("file.txt");
    BufferedReader br = new BufferedReader(reader);
    System.out.println(br.readLine());
    br.close();
} catch (FileNotFoundException e) {
    System.out.println("파일을 찾을 수 없습니다.");
} catch (IOException e) {
    System.out.println("파일 읽기 중 오류가 발생했습니다.");
}
```
위 코드에서 `FileReader`가 파일을 읽지 못하면 `FileNotFoundException`이 발생하고, 파일 읽기 도중 문제가 발생하면 `IOException`이 발생합니다.

---

### **실행 예외 (Runtime Exception, Unchecked Exception)**
- 프로그램 실행 중에 발생하는 예외입니다.
- 컴파일 시점에는 문제가 없지만, 실행하면서 발생합니다.

#### **예외 종류 및 설명**
| **예외 종류**              | **설명**                                                               |
|---------------------------|------------------------------------------------------------------------|
| NullPointerException      | 객체 참조가 `null`인 경우에 접근할 때 발생.                              |
| ArrayIndexOutOfBoundsException | 배열의 인덱스가 유효 범위를 벗어났을 때 발생.                         |
| ArithmeticException       | 산술 연산 예외, 예를 들어 0으로 나눌 때 발생.                           |
| NumberFormatException     | 문자열을 숫자로 변환하려고 할 때 형식에 맞지 않는 경우 발생.              |
| ClassCastException        | 객체를 잘못된 타입으로 캐스팅하려고 할 때 발생.                          |
| IllegalArgumentException  | 메서드에 부적합한 인자를 전달했을 때 발생.                               |
| IllegalStateException     | 객체가 메서드 호출에 적절하지 않은 상태일 때 발생.                        |
| IndexOutOfBoundsException | 인덱스가 범위를 벗어났을 때, 예를 들어 문자열의 인덱스 접근 시 발생.        |
| UnsupportedOperationException | 지원되지 않는 연산을 요청할 때 발생.                                  |

##### **실행 예외 예제**
```java
public class Main {
    public static void main(String[] args) {
        try {
            String str = null;
            System.out.println(str.length()); // NullPointerException 발생
        } catch (NullPointerException e) {
            System.out.println("Null 값을 참조하고 있습니다.");
        }
    }
}
```

---

### **예외 처리 방법**
#### **try-catch 블록**
- `try-catch` 블록을 사용하여 예외가 발생할 수 있는 코드를 감싸고, 발생한 예외를 `catch` 블록에서 처리합니다.

##### **try-catch 블록 예제**
```java
public class Main {
    public static void main(String[] args) {
        try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[3]); // ArrayIndexOutOfBoundsException 발생
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("배열 인덱스가 범위를 벗어났습니다.");
        }
    }
}
```

#### **throws 키워드**
- 메서드가 예외를 직접 처리하지 않고 호출한 쪽으로 예외를 던질 때 사용합니다.
- 주로 **체크 예외**를 처리할 때 사용됩니다.

##### **throws 키워드 예제**
```java
public void readFile(String fileName) throws IOException {
    BufferedReader br = new BufferedReader(new FileReader(fileName));
    System.out.println(br.readLine());
    br.close();
}
```

#### **finally 블록**
- `finally` 블록은 예외 발생 여부와 관계없이 항상 실행됩니다.
- 주로 리소스를 해제하거나 정리하는 코드를 포함하는 데 사용됩니다.

##### **finally 블록 예제**
```java
public class Main {
    public static void main(String[] args) {
        try {
            int[] numbers = {1, 2, 3};
            System.out.println(numbers[5]);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("배열 인덱스가 범위를 벗어났습니다.");
        } finally {
            System.out.println("이 블록은 항상 실행됩니다.");
        }
    }
}
```

## **Chap 10. 컬렉션**

### **자료구조**
#### **정의와 종류**
- 프로그램 작성 시 여러 데이터가 필요할 때 효율적으로 데이터를 관리하기 위해 사용됩니다.
- 예를 들어, 100개의 동일한 데이터를 각각 변수에 할당하면 100개의 변수가 필요합니다.
- 이를 해결하기 위해 하나의 데이터 타입으로 여러 데이터를 처리할 수 있도록 만들어진 개념입니다.
- 대표적인 자료구조 형태: **Array, List, Map**.

---

### **배열(Array)**
#### **특징**
- 전통적으로 기본이 되는 자료구조.
- 데이터를 순차적으로 저장하며 **0부터 시작하는 인덱스**를 통해 접근합니다.
- 단순한 문자나 숫자 등으로 이루어진 집합형 데이터를 처리할 때 유용합니다.

#### **배열의 장단점**
- **장점**:
  - 순차적으로 사용하는 데이터에 적합.
  - 고정된 크기와 동일한 데이터 타입을 통해 메모리 효율성을 높일 수 있음.
- **단점**:
  - 배열 크기가 고정되어 동적으로 변경이 불가능.
  - 배열 중간에 값을 추가하거나 삭제하려면 모든 데이터를 이동해야 함.
  - 동일한 자료형만 저장 가능.

#### **배열 예제**
```java
public class Main {
    public static void main(String[] args) {
        Integer[] array = new Integer[]{1, 2, 3};
        for (int num : array) {
            System.out.println(num);
        }
    }
}
```

---

### **리스트(List)**
#### **특징**
- 배열과 유사한 순차적인 자료구조를 제공합니다.
- 배열의 단점을 보완하여 **동적 크기 변경**, **다양한 데이터 조작 방법** 등을 제공합니다.
- 인덱스를 통해 데이터에 접근할 수 있습니다.

#### **리스트의 장단점**
- **장점**:
  - 데이터 크기가 고정되지 않아 동적 추가/삭제 가능.
  - 배열 중간에 값을 추가하거나 삭제하기 쉬움.
  - 서로 다른 자료형의 데이터도 저장 가능.
- **단점**:
  - 검색 성능이 배열보다 낮을 수 있음.
  - 특정 데이터 검색 시 별도의 구현 필요.

#### **리스트 예제**
```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3));
        list.add(4); // 데이터 추가
        list.remove(1); // 데이터 삭제

        for (int num : list) {
            System.out.println(num);
        }
    }
}
```

---

### **맵(Map)**
#### **특징**
- 데이터를 **키와 값의 쌍(Key-Value Pair)**으로 저장하는 자료구조.
- 데이터를 접근하기 위해 **키(Key)**를 사용합니다.
- 검색 성능이 배열이나 리스트보다 우수합니다.

#### **맵의 장단점**
- **장점**:
  - 키를 사용하여 데이터 검색이 효율적.
  - 중복된 값을 허용하되, 키는 중복 불가.
  - 특정 데이터를 빠르게 찾거나 수정 가능.
- **단점**:
  - 데이터 순서가 보장되지 않을 수 있음.
  - 메모리 사용량이 상대적으로 높음.

#### **맵 예제**
```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("one", 1);
        map.put("two", 2);
        map.put("three", 3);

        System.out.println(map.get("two")); // 키를 이용한 값 검색

        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
        }
    }
}
```

### **컬렉션**
#### **정의와 종류**
- 연관 있는 자료들을 모아놓은 자료구조.
- 데이터를 효율적으로 저장, 관리, 검색할 수 있도록 설계된 구조.
- 자바에서 데이터를 유용하게 담기 위해 만들어둔 인터페이스.
- 인터페이스이기 때문에 사용자들이 사용하려면 인터페이스를 상속받아 정의해야 하며, 자바에서는 이러한 클래스를 제공하여 언제든 사용 가능.
- 주요 컬렉션: **List, Set, Queue, Map**.

#### **Collection Interface**
- 데이터를 그룹으로 관리하기 위한 주요 인터페이스.

#### **Map Interface**
- 키와 값의 쌍으로 데이터를 저장하고 관리하기 위한 인터페이스.

---

### **컬렉션 종류의 특징**
#### **인터페이스 별 특징**
| **인터페이스** | **대표적인 구현 클래스**                     | **설명**                                                                 |
|----------------|-------------------------------------------|-------------------------------------------------------------------------|
| Set<E>         | HashSet, LinkedHashSet, TreeSet          | 순서를 유지하지 않는 데이터 집합으로, 중복을 허용하지 않음.             |
| List<E>        | LinkedList, Stack, Vector, ArrayList     | 순서가 있는 데이터 집합으로, 중복을 허용.                                |
| Queue<E>       | LinkedList, PriorityQueue                | 순서가 있는 데이터 집합으로, 선입선출(FIFO) 구조를 따름. 중복을 허용.    |
| Map<K,V>       | Hashtable, HashMap, LinkedHashMap, SortedMap | 키와 값으로 이루어진 데이터 집합으로, 키는 중복을 허용하지 않고 값은 중복 허용. |

---

### **셋(Set) 특징**
- 저장된 요소들은 순서가 없으며, 데이터를 중복으로 저장할 수 없습니다.
- 인덱스를 사용하지 않고, `iterator`를 통해 요소에 접근합니다.
- 자바에서 제공되는 주요 Set 구현체:
  - **HashSet**: 순서를 보장하지 않음.
  - **TreeSet**: 저장된 데이터의 값에 따라 정렬.
  - **LinkedHashSet**: 데이터가 들어간 순서를 유지.

#### **Set 주요 메서드**
| **메서드명**        | **설명**                                 |
|---------------------|-----------------------------------------|
| `Set.add(object)`   | Set 객체에 요소를 추가.                  |
| `Set.remove(object)`| Set 객체에 전달된 요소를 제거.           |
| `Set.clear()`       | Set 객체의 모든 요소를 제거.             |
| `Set.size()`        | Set 객체의 요소 총 개수를 반환.          |
| `Set.contains(object)` | Set 객체에 요소 존재 여부를 반환 (`true` 또는 `false`). |
| `Set.isEmpty()`     | Set 객체가 비어있는지 여부를 반환 (`true` 또는 `false`). |

---

### **HashSet 특징**
- 순서를 보장하지 않는 Set.
- 가장 일반적인 Set이며, **Hash 알고리즘**을 적용한 자료구조로 가장 빠른 성능 제공.

---

### **TreeSet 특징**
- **Binary Search Tree** 구조를 사용.
- 추가와 삭제 시 시간이 더 걸리지만, **정렬 및 탐색** 성능이 뛰어남.
- 저장된 데이터의 값에 따라 정렬됩니다.

---

### **LinkedHashSet 특징**
- 데이터가 들어간 순서대로 저장.
- **해시 테이블**을 사용하여 요소의 유일성을 보장.
- **연결 리스트**를 사용하여 요소의 순서를 기록합니다.

### **HashSet 특징**
- 순서를 보장하지 않는 Set.
- 가장 일반적인 Set이며, **Hash 알고리즘**을 적용한 자료구조로 가장 빠른 성능 제공.

### **HashSet 효율성 예제**
```java
import java.util.HashSet;

public class Main {
    public static void main(String[] args) {
        HashSet<Integer> set = new HashSet<>();
        set.add(1);
        set.add(2);
        set.add(2); // 중복 요소 추가 시 무시

        for (int num : set) {
            System.out.println(num); // 출력: 1, 2
        }
    }
}
```

---

### **TreeSet 예제**
```java
import java.util.TreeSet;

public class Main {
    public static void main(String[] args) {
        TreeSet<Integer> treeSet = new TreeSet<>();
        treeSet.add(3);
        treeSet.add(1);
        treeSet.add(2);

        for (int num : treeSet) {
            System.out.println(num); // 출력: 1, 2, 3 (정렬된 순서)
        }
    }
}
```

---

### **LinkedHashSet 예제**
```java
import java.util.LinkedHashSet;

public class Main {
    public static void main(String[] args) {
        LinkedHashSet<String> linkedSet = new LinkedHashSet<>();
        linkedSet.add("A");
        linkedSet.add("C");
        linkedSet.add("B");

        for (String value : linkedSet) {
            System.out.println(value); // 출력: A, C, B (입력된 순서)
        }
    }
}
```

---

### **리스트(List) 특징**
- 저장된 요소들이 순서가 있고 데이터 중복이 가능합니다.
- **컬렉션(Collection) 인터페이스** 중 하나이며, `ArrayList`와 `LinkedList` 두 종류로 존재합니다.
- 초기 크기를 지정하지 않아도 되며, 크기 조절이 가능합니다.
- 데이터 삭제 시 데이터 공간을 지웁니다.

#### **리스트(List) 주요 메서드**
| **메서드명**               | **설명**                                                                 |
|----------------------------|-------------------------------------------------------------------------|
| `List.add(value)`          | 데이터 추가. 기존 데이터가 존재하는 인덱스 다음 인덱스에 `value` 저장.     |
| `List.add(index, value)`   | 중간 데이터 삽입. 이후 값들은 인덱스 값이 1씩 증가.                      |
| `List.set(index, value)`   | 인덱스 위치의 값을 치환.                                               |
| `List.remove(index)`       | 인덱스 위치에 있는 값을 삭제.                                          |
| `List.get(index)`          | 인덱스 위치에 있는 값을 반환.                                          |
| `List.size()`              | 리스트의 크기(길이)를 반환.                                            |

---

### **ArrayList 특징**
- 데이터를 순차적으로 추가합니다.
- 배열과 유사하지만, 크기를 지정하지 않아도 데이터 추가 시 크기가 증가합니다.

#### **ArrayList 예제**
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>();
        list.add(10);
        list.add(20);
        list.add(30);

        for (int num : list) {
            System.out.println(num); // 출력: 10, 20, 30
        }
    }
}
```

---

### **LinkedList 특징**
- 데이터가 링크되어 저장됩니다.
- 하나의 데이터는 이전 데이터와 다음 데이터의 주소들을 연결합니다.
- 리스트 중간에 데이터 추가 시 이전 주소의 연결을 끊고 새로 연결합니다.
- 자바 `LinkedList`는 **더블 링크드 리스트(Double Linked List)** 데이터 구조를 사용합니다.
- 요소의 삽입과 삭제가 빈번하게 일어나는 경우 유용합니다.

#### **LinkedList 예제**
```java
import java.util.LinkedList;

public class Main {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        list.add("First");
        list.add("Second");
        list.addFirst("Zeroth"); // 맨 앞에 데이터 추가

        for (String value : list) {
            System.out.println(value); // 출력: Zeroth, First, Second
        }
    }
}
```

---

### **CustomLinkedList 예제**
```java
class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class CustomLinkedList {
    private Node head;

    public void add(int data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
        } else {
            Node current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }
    }

    public void printList() {
        Node current = head;
        while (current != null) {
            System.out.print(current.data + " -> ");
            current = current.next;
        }
        System.out.println("null");
    }
}

public class Main {
    public static void main(String[] args) {
        CustomLinkedList list = new CustomLinkedList();
        list.add(10);
        list.add(20);
        list.add(30);
        list.printList(); // 출력: 10 -> 20 -> 30 -> null
    }
}
```

### **큐(Queue) 특징**
- FIFO(First-In-First-Out, 선입선출) 원칙을 따라 요소를 관리.
- 첫 번째로 추가된 요소가 첫 번째로 제거됩니다.
- 주요 구현체: `LinkedList`, `PriorityQueue`, `ArrayDeque`.
- 데이터의 순차적 처리를 효율적으로 할 수 있습니다.
- 멀티 스레딩 환경에서도 안전하게 사용할 수 있는 동기화된 큐를 제공합니다.

#### **큐(Queue) 주요 메서드**
| **메서드명**             | **설명**                                                                 |
|--------------------------|-------------------------------------------------------------------------|
| `Queue.add(value)`       | 큐의 맨 뒤에 값 추가.                                                   |
| `Queue.element()`        | 큐의 맨 앞 값을 반환. 큐가 비어 있을 경우 `NoSuchElementException` 발생. |
| `Queue.peek()`           | 큐의 맨 앞 값을 반환. 큐가 비어 있을 경우 `null` 반환.                 |
| `Queue.poll()`           | 큐의 맨 앞 값을 반환 후 삭제. 큐가 비어 있을 경우 `null` 반환.          |
| `Queue.remove()`         | 큐의 맨 앞 값을 반환 후 삭제. 큐가 비어 있을 경우 `NoSuchElementException` 발생. |
| `Queue.clear()`          | 큐 전체 데이터를 비웁니다.                                              |

---

### **큐(Queue) 예제**
```java
import java.util.LinkedList;
import java.util.Queue;

public class Main {
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();
        queue.add(1);
        queue.add(2);
        queue.add(3);

        System.out.println(queue.peek()); // 출력: 1 (맨 앞 값)
        System.out.println(queue.poll()); // 출력: 1 (맨 앞 값 제거 후 반환)
        System.out.println(queue.size()); // 출력: 2
    }
}
```

---

### **맵(Map) 특징**
- 키(key)와 값(value) 쌍의 형태로 이루어져 있으며, 보통 **검색**을 목적으로 사용됩니다.
- 데이터의 순서가 없으며, 중간 삽입도 없습니다.
- **키(key)**는 중복이 불가하지만, **값(value)**은 중복 가능합니다.
- **키(key)**는 내부적으로 Set에 저장됩니다.

#### **맵(Map) 주요 메서드**
| **메서드명**           | **설명**                                                              |
|------------------------|----------------------------------------------------------------------|
| `Map.put(key, value)`  | 키(key)와 값(value)으로 이루어진 데이터 추가.                         |
| `Map.get(key)`         | 키(key)에 저장된 데이터를 반환.                                       |
| `Map.remove(key)`      | 키(key) 데이터를 삭제.                                                |
| `Map.size()`           | Map 데이터의 크기(사이즈)를 반환.                                    |
| `Map.containsKey(key)` | Map 데이터에 키(key) 존재 여부를 반환 (`true` 또는 `false`).          |
| `Map.containsValue(value)` | Map 데이터에 값(value) 존재 여부를 반환 (`true` 또는 `false`).      |

---

### **HashMap 특징**
- 동기화를 지원하지 않아 멀티 스레드 환경에서 데이터 일관성을 보장하지 않습니다.
  - 단일 스레드 개발 환경에서 사용 추천.
- 키(key)와 값(value)에 `null` 데이터를 추가할 수 있습니다.
- 중복된 키(key)로 값(value)을 저장할 경우, **신규 데이터로 대체**됩니다.

#### **HashMap 예제**
```java
import java.util.HashMap;

public class Main {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();
        map.put("A", 1);
        map.put("B", 2);
        map.put("A", 3); // 기존 키 "A"의 값이 3으로 대체

        System.out.println(map.get("A")); // 출력: 3
        System.out.println(map.size());   // 출력: 2
    }
}
```

---

### **HashTable 특징**
- 동기화를 지원하며, 멀티 스레드 환경에서 데이터 일관성을 보장합니다.
- 키(key)와 값(value)에 `null` 데이터를 추가할 수 없습니다.
- 중복된 키(key)로 값(value)을 저장할 경우, **이전 데이터 유지**됩니다.

#### **HashTable 예제**
```java
import java.util.Hashtable;

public class Main {
    public static void main(String[] args) {
        Hashtable<String, Integer> table = new Hashtable<>();
        table.put("X", 100);
        table.put("Y", 200);

        // table.put(null, 300); // 에러 발생: 키에 null 추가 불가

        System.out.println(table.get("X")); // 출력: 100
        System.out.println(table.containsKey("Y")); // 출력: true
    }
}
```
### **컬렉션 전체 특징**
| Collection              | Ordering | Random Access | Key-Value | Duplicate Elements | Null Element | Thread Safe |
|-------------------------|----------|---------------|-----------|--------------------|--------------|-------------|
| ArrayList              | Yes      | Yes           | No        | Yes                | Yes          | No          |
| LinkedList             | Yes      | No            | No        | Yes                | Yes          | No          |
| HashSet                | No       | No            | No        | No                 | Yes          | No          |
| TreeSet                | Yes      | No            | No        | No                 | No           | No          |
| HashMap                | No       | No            | Yes       | Yes                | Yes          | No          |
| TreeMap                | Yes      | No            | Yes       | Yes                | No           | No          |
| Vector                 | Yes      | Yes           | No        | Yes                | Yes          | Yes         |
| Hashtable              | No       | No            | Yes       | No                 | No           | Yes         |
| Properties             | No       | No            | Yes       | No                 | No           | Yes         |
| Stack                  | Yes      | No            | No        | Yes                | Yes          | Yes         |
| CopyOnWriteArrayList   | Yes      | Yes           | No        | Yes                | Yes          | Yes         |
| ConcurrentHashMap      | No       | No            | Yes       | No                 | Yes          | Yes         |
| CopyOnWriteArraySet    | No       | No            | No        | No                 | Yes          | Yes         |
