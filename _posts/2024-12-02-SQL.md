--- 
title: "SQL(Structured Query Language) | SQL(Structured Query Language)" 
date: 2024-12-02 09:40:00 +0900
achieved: 2024-12-04 17:30:00 +0900
math: true
categories: [Bootcamp, KT Aivle School]
tags: [Bootcamp, KT Aivle School, SQL, Structured Query Language]
---
---------- 
> SQL 기초 정리 글입니다. 
{: .prompt-info } 

## **SQL**
### **SQL 문이란?**
- **SQL**: Structured Query Language
- 데이터베이스에서 데이터를 조회하거나 처리(입력, 수정, 삭제)할 때 사용하는 구문
- SQL 표준의 발전: **SQL-86 → SQL-92 → SQL:1999 → SQL:2003 → SQL:2008 → SQL:2011 → SQL:2016**
- 한 제품에서 SQL 사용이 익숙하면 다른 제품에서도 사용이 가능
- 제품마다 호환되지 않는 SQL문도 존재

### **SQL의 주요 기능**
- **데이터 정의(DDL, Data Definition Language)**: 테이블, 뷰, 인덱스 등의 데이터베이스 구조 정의
- **데이터 조작(DML, Data Manipulation Language)**: 데이터 조회, 삽입, 삭제, 갱신
- **데이터 제어(DCL, Data Control Language)**: 권한 부여 및 회수, 트랜잭션 관리

| **SQL 구문** | **설명** | **예시** |
|--------------|----------|-----------|
| **SELECT** | 데이터를 조회하는 구문 | `SELECT * FROM employee;` |
| **INSERT** | 테이블에 데이터를 삽입 | `INSERT INTO employee (emp_id, emp_name) VALUES ('S001', '김철수');` |
| **UPDATE** | 기존 데이터를 수정 | `UPDATE employee SET salary = 5000 WHERE emp_id = 'S001';` |
| **DELETE** | 데이터를 삭제 | `DELETE FROM employee WHERE emp_id = 'S001';` |
| **CREATE TABLE** | 새로운 테이블 생성 | `CREATE TABLE department (dept_id VARCHAR(10), dept_name VARCHAR(50));` |
| **DROP TABLE** | 테이블 삭제 | `DROP TABLE department;` |
| **ALTER TABLE** | 기존 테이블 수정 | `ALTER TABLE employee ADD COLUMN address VARCHAR(100);` |
| **GRANT** | 사용자에게 권한 부여 | `GRANT SELECT ON employee TO user1;` |
| **REVOKE** | 사용자에게 부여한 권한 회수 | `REVOKE SELECT ON employee FROM user1;` |

### **SQL 예시 코드**
1. **데이터 조회 (SELECT)**
```sql
-- employee 테이블의 모든 컬럼 조회
SELECT * FROM employee;

-- 특정 컬럼 조회
SELECT emp_id, emp_name, salary FROM employee;

-- 조건에 맞는 데이터만 조회
SELECT * FROM employee WHERE salary > 5000;

-- 정렬하여 조회 (급여를 기준으로 내림차순 정렬)
SELECT * FROM employee ORDER BY salary DESC;
```

2. **데이터 삽입 (INSERT)**
```sql
-- employee 테이블에 데이터 삽입
INSERT INTO employee (emp_id, emp_name, gender, hire_date, dept_id, salary) 
VALUES ('S021', '박준영', 'M', '2024-01-01', 'D001', 4500);
```

3. **데이터 수정 (UPDATE)**
```sql
-- 급여 정보를 수정
UPDATE employee 
SET salary = 5500 
WHERE emp_id = 'S001';
```

4. **데이터 삭제 (DELETE)**
```sql
-- 특정 조건에 맞는 데이터를 삭제
DELETE FROM employee WHERE emp_id = 'S021';
```

5. **테이블 생성 (CREATE TABLE)**
```sql
-- 새로운 테이블 생성
CREATE TABLE department (
    dept_id VARCHAR(10) PRIMARY KEY,
    dept_name VARCHAR(50) NOT NULL,
    start_date DATE
);
```

6. **테이블 삭제 (DROP TABLE)**
```sql
-- 테이블 삭제
DROP TABLE department;
```

7. **테이블 변경 (ALTER TABLE)**
```sql
-- employee 테이블에 새로운 컬럼 추가
ALTER TABLE employee ADD COLUMN address VARCHAR(100);
```

8. **권한 부여 및 회수 (GRANT, REVOKE)**
```sql
-- user1 사용자에게 employee 테이블의 SELECT 권한 부여
GRANT SELECT ON employee TO user1;

-- user1 사용자로부터 SELECT 권한 회수
REVOKE SELECT ON employee FROM user1;
```

---

## **Chap 1. 데이터 기본 조회**

***

### **hrdb2024 데이터베이스**
- 이후 학습을 위해 사용하는 예제 인사관리 데이터베이스
- 제공된 스크립트 파일을 사용해 만들고 이후 과정 준비

![image](https://github.com/user-attachments/assets/c301b940-b430-4fb9-b165-7d0daa262b79)

#### **employee 테이블**
- 20명 직원 정보를 가지고 있음

| **컬럼명** | **설명** |
|------------|----------|
| **emp_id (PK)** | 사원번호(Sxxxx 형태) |
| **emp_name** | 직원 이름 |
| **eng_name** | 법칭(영어 이름) |
| **gender** | 성별(M, F 중 하나) |
| **marital_yn** | 결혼 여부(Y, N 중 하나) |
| **hire_date** | 입사일 |
| **retire_date** | 퇴사일(근무자는 NULL) |
| **dept_id (FK)** | 직원이 속한 부서 코드 |
| **phone** | 전화번호 |
| **email** | 이메일 주소 |
| **salary** | 급여(만 단위 연봉) |

#### **department 테이블**
- 7개 부서(팀) 정보를 가지고 있음
- [전략기획]을 제외한 모든 부서는 본부에 포함됨
- 몇몇 부서는 직원이 없음

| **컬럼명** | **설명** |
|------------|----------|
| **dept_id (PK)** | 부서 코드 |
| **dept_name** | 부서 이름 |
| **unit_id (FK)** | 부서가 속한 본부 코드 |
| **start_date** | 부서 시작 날짜 |

#### **unit 테이블**
- 3개 본부 정보를 가지고 있음
- 회사를 본부제로 운영한다고 가정한 것
- 본부는 몇몇 부서들을 포함함

| **컬럼명** | **설명** |
|------------|----------|
| **unit_id (PK)** | 본부 코드(A, B, C 중 하나) |
| **unit_name** | 본부 이름 |

#### **vacation 테이블**
- 직원들 휴가 이력을 가지고 있음

| **컬럼명** | **설명** |
|------------|----------|
| **vacation_id (PK)** | 휴가 일련번호 |
| **emp_id (FK)** | 사원번호 |
| **begin_date** | 휴가 시작일 |
| **end_date** | 휴가 종료일 |
| **reason** | 휴가 사유 |
| **duration** | 휴가 일수 |

#### **toeic 테이블**
- 직원들 토익 시험 점수를 가지고 있음
- 총 10번의 토익 시험을 볼 수 있음

| **컬럼명** | **설명** |
|------------|----------|
| **emp_id (PK, FK)** | 사원번호 |
| **score01 ~ score10** | 토익 점수 |

#### **club 테이블**
- 사내 동호회에 대한 정보를 가지고 있음

| **컬럼명** | **설명** |
|------------|----------|
| **club_id (PK)** | 동호회 코드 |
| **club_name** | 동호회 이름 |
| **start_date** | 동호회 시작일 |
| **fee** | 동호회 월회비 |

#### **club_join 테이블**
- 직원들 동호회 가입 이력을 가지고 있음

| **컬럼명** | **설명** |
|------------|----------|
| **join_id (PK)** | 가입 일련번호 |
| **emp_id (FK)** | 사원번호 |
| **club_id (FK)** | 동호회 코드 |
| **join_date** | 동호회 가입일 |
| **cancel_date** | 동호회 탈퇴일(활동자는 NULL) |

---

### **MySQL Workbench 구성**

![image](https://github.com/user-attachments/assets/73718f5b-d34a-4323-9bf8-771cca899ff8)

---

### **쿼리문 작성 방법**

#### **작성 규칙**
- **주석**
  - 주석은 남기는 순서가 필요.
  - 쿼리문에 대한 충분한 설명을 주석으로 남김.
  - 여러 줄 주석의 예시:
  ```sql
  /*
  작성: 쿼리문 작성 방법
  작성자: 홍길동
  날짜: 2022년 12월 29일
  */
  ```

- **쿼리문**
  - 적절한 들여쓰기와 내어쓰기 사용.
  - 구문 마지막은 세미콜론(;)으로 마무리.

#### **쿼리문 작성 예시**
```sql
SELECT customer_name, 
       customer_id, 
       gender, 
       register_date, 
       point + 1000 AS new_point -- 프로모션의 일부: 1,000점 더하기 이벤트 (2022.12.29)
FROM customer
WHERE city = '서울' AND point > 0
ORDER BY customer_name ASC;
```

---
### **단순 조회**

#### **SELECT 문 기본 개념**
- **SELECT 문**이 가장 기본이 되면서 가장 많이 사용하는 쿼리문
- 대부분의 SELECT 문은 FROM 절을 사용해 테이블에서 데이터를 조회함.
- 하지만 SELECT 문에 FROM 절이 꼭 필요한 것은 아님.
- 특정 값, 계산식 또는 함수 결과를 조회할 수 있음.
- `AS`를 사용해 표시되는 열의 별칭을 지정할 수 있음.

#### **예제 코드**
```sql
SELECT 'Hello SQL World';
SELECT 'Hello SQL World' AS Start;
SELECT 10 + 20 AS Result;
SELECT CURDATE() AS Today;
SET @Today = CURDATE();
SELECT @Today;
```
> 참고: 어떤 DBMS는 SELECT 문에 FROM 절을 필수적으로 요구합니다. 예를 들어, ORACLE이 그렇습니다.

---

### **테이블에 대한 이해**
- **테이블은 다음과 같이 행(Row)과 열(Column)로 구성됨.**
- 대부분의 테이블은 제한된 개수의 열과 수천 수만 개의 행을 가짐.
- SQL문을 사용해 특정 조건에 맞는 행과 몇몇 열을 조회하는 것이 일반적임.

#### **테이블 구성 예시**
| **사원번호** | **이름**   | **성별** | **입사일**       | **전자우편**           | ... |
|--------------|------------|----------|-----------------|-----------------------|-----|
| S0001        | 홍길동     | 남       | 2006-01-01      | hong@dbnuri.com       | ... |
| S0002        | 김재은     | 여       | 2006-01-01      | jimae@dbnuri.com      | ... |
| S0003        | 우동       | 남       | 2006-04-01      | udong@dbnuri.com      | ... |
| S0004        | 이삼식     | 남       | 2007-01-01      | samsik@dbnuri.com     | ... |
| S0005        | 최치국     | 남       | 2007-03-01      | chikook@dbnuri.com    | ... |
| S0006        | 안은혜     | 여       | 2007-06-01      | anne@dbnuri.com       | ... |
| S0008        | 박여사     | 여       | 2007-07-01      | yeosa@dbnuri.com      | ... |
| ...          | ...        | ...      | ...             | ...                   | ... |

#### **구조 설명**
- **열(Column):** 데이터의 속성을 정의. 예: `사원번호`, `이름`, `성별`.
- **행(Row):** 하나의 데이터를 나타냄. 예: 특정 사원의 정보.

---

### **기본적인 데이터 조회**
```sql
-- 기본 구문
SELECT 열1, 열2, ...
FROM 테이블
WHERE 조건;
```
- **SELECT 절**: 조회할 열 이름이나 수식 등을 보고자 하는 순서로 나열.
  - 모든 열을 보고자 하는 경우는 `*`을 입력함.
- **FROM 절**: 조회 대상 테이블, 뷰 또는 테이블 형태를 반환하는 함수나 하위 쿼리문을 입력.
- **WHERE 절**: 행 추출을 위한 조건을 입력하며, 조건을 생략하면 모든 행이 조회 대상이 됨.

#### **예제**
```sql
SELECT emp_id, emp_name 
FROM employee 
WHERE dept_id = 'SYS';
```
> **설명:** employee 테이블에서 dept_id 값이 'SYS'인 행의 emp_id와 emp_name을 조회하는 구문.

---

### **조회 대상 열 지정**
- **열 이름 대신 `*`를 입력**하고 조건을 입력하지 않으면 테이블의 모든 행의 모든 열을 조회함.
- 모든 열을 의미하는 `*`는 All 이라고 읽음.
- 표시되는 열 순서는 테이블을 만들 때 지정한 열 순서와 동일함.

#### **예제 코드**
```sql
SELECT * FROM employee;
SELECT * FROM department;
```

- **열 이름을 입력하고 조건을 입력하지 않으면** 모든 행의 지정한 열을 조회함.
- 보고자 하는 순서대로 열 이름을 정확히 입력해야 함.
- 원하는 순서로 나열하면 되나, 테이블에 정의한 열 순서는 조회에서 의미가 없음.

#### **예제 코드**
```sql
SELECT emp_id, emp_name FROM employee;
SELECT emp_name, emp_id FROM employee;
```

---

### **조회 대상 조건 지정**
- **열 이름 대신 `*`를 입력**하고 조건을 입력하면 조건에 맞는 행의 모든 열을 조회함.

#### **예제 코드**
```sql
SELECT * FROM employee WHERE emp_id = 'S0001';
SELECT * FROM vacation WHERE emp_id = 'S0002';
```

- **열 이름을 입력하고 조건을 입력**하면 조건에 맞는 행의 지정한 열을 조회함.
- 가장 적절한 조회 형태라고 할 수 있음.

#### **예제 코드**
```sql
SELECT emp_id, emp_name FROM employee WHERE emp_id = 'S0001';
SELECT dept_id, dept_name FROM department WHERE dept_id = 'SYS';
```

- 조건을 잘못 지정하면 오류 대신 **의도하지 않은 결과**를 얻게 됨.
- 잘못된 결과를 조회하기보다는 차라리 오류가 발생하는 것이 더 좋을 수도 있음.
- 조회된 결과에 대한 **정확성을 항상 확인**하는 습관이 필요함.

---

### **비교 연산자**

- **크기를 비교할 때 사용하는 연산자**로, 대부분 WHERE 절에서 조건을 정의할 때 사용
- 정확한 조회 결과를 얻기 위해 쿼리문 작성 시 가장 신중해야 할 부분
- 일반적으로 **숫자의 크기**를 비교하지만, **문자와 날짜**도 크기를 비교할 수 있음
- **같지 않다(다르다)**는 `<>` 또는 `!=` 연산자를 사용함

#### **예제 코드**
```sql
SELECT * FROM employee WHERE dept_id = 'SYS';
SELECT * FROM employee WHERE salary > 7000;
SELECT * FROM employee WHERE hire_date < '2019-02-28';
SELECT * FROM employee WHERE dept_id <> 'SYS';
```

#### **연산자 종류**
| **연산자** | **설명** |
|------------|----------|
| **=** | 같다 |
| **>** | 크다 |
| **<** | 작다 |
| **>=** | 크거나 같다 |
| **<=** | 작거나 같다 |
| **<>** | 같지 않다 |
| **!=** | 같지 않다 (일부 DBMS에서 사용 가능) |

---

### **문자열 조건 지정**

- **문자열 데이터는 다양한 조건의 검색이 요구됨**
- **LIKE 연산자**로 문자 패턴을 비교해 원하는 데이터를 조회할 수 있음

#### **예제 코드**
```sql
-- 이름에 '국'이 들어간 직원 조회
SELECT * FROM employee WHERE emp_name LIKE '%국%';

-- 이름이 '국'으로 끝나는 직원 조회
SELECT * FROM employee WHERE emp_name LIKE '%국';

-- 이메일 아이디가 4글자인 직원 조회 ('_' 하나가 글자 하나를 의미)
SELECT * FROM employee WHERE email LIKE '____@%';
```

---

### **논리 연산자**

- **WHERE 절에서 여러 개의 조건을 연결하는 연산자**
- **AND 연산자**: 조건을 만족할 수록 결과 행이 줄어듦 → 성능 면에서 긍정적

#### **예제 코드**
```sql
SELECT * FROM employee 
WHERE salary > 5000 AND hire_date <= '2020-12-31';
```

- **OR 연산자**: 조건을 만족할 수록 결과 행이 늘어남 → 성능 면에서 부정적

#### **예제 코드**
```sql
SELECT * FROM employee 
WHERE dept_id = 'SYS' OR dept_id = 'MKT';
```

- **NOT 연산자**: 조건에 대한 부정을 의미 (NOT LIKE, NOT IN, NOT BETWEEN, IS NOT NULL 등)

#### **예제 코드**
```sql
SELECT * FROM employee 
WHERE phone NOT LIKE '010%';
```

> **Note:** 여러 조건을 나열할 경우에는 괄호를 사용해 조건을 명확히 식별할 수 있도록 해야 함

---

### **범위 조건과 리스트 조건**

- WHERE 절에 조건을 간결하게 입력할 수 있는 방법 → **가독성 향상**
- 조건에 열 이름을 반복해서 입력하는 번거로움을 해결함

#### **범위 조건 사용 예제 (BETWEEN)**

```sql
SELECT * FROM employee 
WHERE salary >= 5000 AND salary <= 8000;

SELECT * FROM employee 
WHERE salary BETWEEN 5000 AND 8000;
```

#### **리스트 조건 사용 예제 (IN)**

```sql
SELECT * FROM employee 
WHERE dept_id = 'SYS' OR dept_id = 'MKT' OR dept_id = 'HRD';

SELECT * FROM employee 
WHERE dept_id IN ('SYS', 'MKT', 'HRD');
```

#### **NOT 연산자 사용 예제**

```sql
SELECT * FROM employee 
WHERE salary NOT BETWEEN 5000 AND 8000;

SELECT * FROM employee 
WHERE dept_id NOT IN ('SYS', 'MKT', 'HRD');
```

### **비교 연산자**

- **크기를 비교할 때 사용하는 연산자**로, 대부분 WHERE 절에서 조건을 정의할 때 사용
- 정확한 조회 결과를 얻기 위해 쿼리문 작성 시 가장 신중해야 할 부분
- 일반적으로 **숫자의 크기**를 비교하지만, **문자와 날짜**도 크기를 비교할 수 있음
- **같지 않다(다르다)**는 `<>` 또는 `!=` 연산자를 사용함

#### **예제 코드**
```sql
SELECT * FROM employee WHERE dept_id = 'SYS';
SELECT * FROM employee WHERE salary > 7000;
SELECT * FROM employee WHERE hire_date < '2019-02-28';
SELECT * FROM employee WHERE dept_id <> 'SYS';
```

#### **연산자 종류**
| **연산자** | **설명** |
|------------|----------|
| **=** | 같다 |
| **>** | 크다 |
| **<** | 작다 |
| **>=** | 크거나 같다 |
| **<=** | 작거나 같다 |
| **<>** | 같지 않다 |
| **!=** | 같지 않다 (일부 DBMS에서 사용 가능) |

---

### **문자열 조건 지정**

- **문자열 데이터는 다양한 조건의 검색이 요구됨**
- **LIKE 연산자**로 문자 패턴을 비교해 원하는 데이터를 조회할 수 있음

#### **예제 코드**
```sql
-- 이름에 '국'이 들어간 직원 조회
SELECT * FROM employee WHERE emp_name LIKE '%국%';

-- 이름이 '국'으로 끝나는 직원 조회
SELECT * FROM employee WHERE emp_name LIKE '%국';

-- 이메일 아이디가 4글자인 직원 조회 ('_' 하나가 글자 하나를 의미)
SELECT * FROM employee WHERE email LIKE '____@%';
```

---

### **논리 연산자**

- **WHERE 절에서 여러 개의 조건을 연결하는 연산자**
- **AND 연산자**: 조건을 만족할 수록 결과 행이 줄어듦 → 성능 면에서 긍정적

#### **예제 코드**
```sql
SELECT * FROM employee 
WHERE salary > 5000 AND hire_date <= '2020-12-31';
```

- **OR 연산자**: 조건을 만족할 수록 결과 행이 늘어남 → 성능 면에서 부정적

#### **예제 코드**
```sql
SELECT * FROM employee 
WHERE dept_id = 'SYS' OR dept_id = 'MKT';
```

- **NOT 연산자**: 조건에 대한 부정을 의미 (NOT LIKE, NOT IN, NOT BETWEEN, IS NOT NULL 등)

#### **예제 코드**
```sql
SELECT * FROM employee 
WHERE phone NOT LIKE '010%';
```

> **Note:** 여러 조건을 나열할 경우에는 괄호를 사용해 조건을 명확히 식별할 수 있도록 해야 함

---

### **범위 조건과 리스트 조건**

- WHERE 절에 조건을 간결하게 입력할 수 있는 방법 → **가독성 향상**
- 조건에 열 이름을 반복해서 입력하는 번거로움을 해결함

#### **범위 조건 사용 예제 (BETWEEN)**

```sql
SELECT * FROM employee 
WHERE salary >= 5000 AND salary <= 8000;

SELECT * FROM employee 
WHERE salary BETWEEN 5000 AND 8000;
```

#### **리스트 조건 사용 예제 (IN)**

```sql
SELECT * FROM employee 
WHERE dept_id = 'SYS' OR dept_id = 'MKT' OR dept_id = 'HRD';

SELECT * FROM employee 
WHERE dept_id IN ('SYS', 'MKT', 'HRD');
```

#### **NOT 연산자 사용 예제**

```sql
SELECT * FROM employee 
WHERE salary NOT BETWEEN 5000 AND 8000;

SELECT * FROM employee 
WHERE dept_id NOT IN ('SYS', 'MKT', 'HRD');
```

---

### **NULL 값 비교**

- **NULL 값은 0도 아니고 공백도 아닌 알 수 없는 값** → Unknown Value
- NULL 값과 문자열 'NULL'은 완전히 다름
- **IS NULL**, **IS NOT NULL**을 사용해 NULL 값을 식별할 수 있음

#### **예제 코드**
```sql
SELECT * FROM employee WHERE eng_name = 'NULL';  -- 문자열 'NULL' 조회
SELECT * FROM employee WHERE eng_name IS NULL;  -- NULL 값 조회
SELECT * FROM employee WHERE retire_date IS NULL;  -- NULL 값 조회
SELECT * FROM employee WHERE retire_date IS NOT NULL;  -- NULL이 아닌 값 조회
```

---

### **IFNULL 함수**

- **IFNULL() 함수를 사용해 NULL 값 대신 다른 값을 표시할 수 있음**
- DBMS마다 다른 함수를 사용함
  - MySQL: IFNULL() 
  - MSSQL: ISNULL() 
  - ORACLE: NVL()

#### **예제 코드**
```sql
SELECT emp_name, emp_id, IFNULL(eng_name, '') AS nick_name,
       gender, dept_id, hire_date
FROM employee
WHERE retire_date IS NULL;

SELECT emp_name, emp_id, COALESCE(eng_name, '') AS nick_name,
       gender, dept_id, hire_date
FROM employee
WHERE retire_date IS NULL;
```

---

### **자동 형 변환**

- **문자열과 숫자의 자동 형 변환 및 문자열 연결**
- 문자열 데이터가 연산에 사용되면 자동으로 숫자로 변환됨 (자동 형 변환)
- 숫자로 변환되지 못하는 문자는 0으로 변환됨

#### **예제 코드**
```sql
SELECT '10' + '20';    -- 30
SELECT 10 + '20';      -- 30
SELECT 10 + '20AX';    -- 10 (문자 'AX'는 숫자로 변환되지 않아 0 처리)
SELECT 10 + 'LX20';    -- 10 (문자 'LX20'은 숫자로 변환되지 않아 0 처리)
```

- **문자열 데이터를 + 연산자로 결합할 수 없음** → **CONCAT** 함수를 사용해야 결합 가능

#### **예제 코드**
```sql
SELECT CONCAT('10', '20');  -- '1020'
SELECT CONCAT(10, '20');    -- '1020'
SELECT CONCAT(10, 20);      -- '1020'
```

---

### **데이터 결합**

- **CONCAT() 함수를 사용해 데이터 결합**
- 결합되는 값에 NULL 값이 포함되면 결합 결과가 NULL이 됨

#### **예제 코드**
```sql
SELECT CONCAT(emp_name, '(', emp_id, ')') AS emp_name,
       dept_id, gender, hire_date, email
FROM employee;

SELECT CONCAT(emp_name, '(', salary, ')') AS emp_name,
       dept_id, gender, hire_date, email
FROM employee;
```

### **데이터 정렬**

#### **ORDER BY 절을 사용한 정렬**
```sql
SELECT 열1, 열2, ...
FROM 테이블
WHERE 조건
ORDER BY 정렬 기준 열 ASC | DESC;
```
- ORDER BY 절을 사용해 정렬된 결과를 표시할 수 있음
- **ASC**: 오름차순 (예: 1, 2, 3, 4 / 가, 나, 다, 라 / A, B, C, D)
- **DESC**: 내림차순 (예: 4, 3, 2, 1 / 라, 다, 나, 가 / D, C, B, A)
- 꼭 필요한 경우만 정렬하기를 권고 (성능 문제 발생 가능)
- **숫자, 문자, 날짜형 데이터 모두 정렬 가능**
- **복합 정렬**은 콤마(,)로 구분해서 정렬 방식을 지정함
- **ASC가 기본값** → 정렬 방식을 지정하지 않으면 오름차순으로 정렬됨

#### **예제 코드**
```sql
SELECT * FROM employee ORDER BY salary DESC; 
SELECT * FROM employee ORDER BY dept_id ASC, emp_id DESC;
```

---

### **CASE 문**

#### **CASE 문 기본 구조**
```sql
CASE WHEN 조건1 THEN 값1
     WHEN 조건2 THEN 값2
     WHEN 조건3 THEN 값3
     ...
     ELSE 값N END;
```
- **CASE 문 설명**
  - CASE 문을 사용하면 쿼리문 안에서 **조건에 따른 처리(값 연산, 변환 등)**를 수행할 수 있음
  - 기본 구문이 다소 길다고 느낄 수 있으나, SELECT 문에서 매우 중요한 역할을 수행함

#### **예제 코드**
```sql
SELECT emp_name, emp_id,
       CASE WHEN gender = 'M' THEN '남자'
            WHEN gender = 'F' THEN '여자'
            ELSE '' END AS gender,
       hire_date, retire_date, salary
FROM employee;
```
> **설명:** gender 열 값이 'M'이면 '남자'로, 'F'면 '여자', 나머지는 공백으로 표시하는 예제

---

### **IF 함수**

#### **IF 함수 기본 구조**
```sql
IF(조건, 값1, 값2)
```
- **조건이 참이면 값1**, **거짓이면 값2**가 선택됨
- CASE 문보다는 상대적으로 구문이 짧아 간결한 쿼리문을 작성할 수 있음
- CASE 문처럼 여러 조건에 따라 분기하여 처리하려면 IF 함수를 **중첩**해서 사용해야 함
- 여러 조건에 따른 처리는 **CASE 문**을, 단 한 번의 조건 비교로 참과 거짓에 따른 처리는 **IF 함수** 사용

#### **예제 코드**
```sql
SELECT emp_name, emp_id,
       IF(gender = 'M', '남자', '여자') AS gender, hire_date
FROM employee;

SELECT emp_name, emp_id,
       IF(gender = 'M', '남자', IF(gender = 'F', '여자', '')) AS gender, hire_date
FROM employee;
```
> **설명:** gender가 'M'이면 '남자', 'F'이면 '여자'로 표시하고, 그 외에는 빈 문자열을 반환

---

## **Chap 2. 데이터베이스 모델링**

---

### **요구 분석 중요성**

- **효율적인 데이터베이스 설계**
  - 정확한 요구 분석은 데이터베이스의 구조를 최적화하여 성능을 향상시킴.

- **비즈니스 요구 충족**
  - 비즈니스 요구사항을 충족시키는 데이터베이스 시스템을 구현할 수 있음.

- **비용 절감**
  - 초기 단계에서 요구사항을 명확히 함으로써 설계 변경으로 인한 추가 비용을 줄일 수 있음.

- **프로젝트 성공률 증가**
  - 명확하고 구체적인 요구사항은 프로젝트의 성공 확률을 높여줌.

---

### **요구 분석 단계**

#### **1. 요구사항 수집**
- **인터뷰**: 사용자, 관리자 등 이해관계자들과의 인터뷰를 통해 요구사항을 수집.
- **설문조사**: 설문지를 통해 조직의 데이터 요구사항을 정량적으로 수집.
- **워크숍 및 브레인스토밍**: 이해관계자들이 한자리에 모여 아이디어를 공유하고 요구사항을 도출.
- **문서 검토**: 기존의 문서, 보고서, 시스템 매뉴얼 등을 검토하여 요구사항을 파악.

#### **2. 요구사항 분석**
- **요구사항 분류**: 수집된 요구사항을 기능적 요구사항과 비기능적 요구사항으로 분류.
- **요구사항 명세화**: 요구사항을 명확하고 상세하게 문서화.
- **우선순위 설정**: 요구사항의 중요도와 긴급도에 따라 우선순위를 매김.

#### **3. 요구사항 검증**
- **요구사항 검증**: 이해관계자들과 함께 요구사항을 검토하여 정확성과 완전성을 확인.
- **프로토타이핑**: 시뮬레이션이나 프로토타입을 만들어 요구사항이 제대로 반영되었는지 확인.
- **피드백 수집**: 이해관계자들로부터 피드백을 받아 요구사항을 수정 및 보완.

---

### **요구 분석 시 고려사항**

#### **1. 명확성 (Clarity)**
- 요구사항은 이해하기 쉽게 명확하게 기술되어야 합니다.
- 애매모호한 표현은 피해야 함.

#### **2. 일관성 (Consistency)**
- 요구사항 간에 모순이 없어야 하며, 시스템의 다른 부분들과 일관성을 유지해야 함.

#### **3. 완전성 (Completeness)**
- 요구사항은 시스템의 모든 측면을 포함해야 하며, 누락된 부분이 없어야 함.

#### **4. 추적 가능성 (Traceability)**
- 각 요구사항은 그 출처를 명확히 할 수 있어야 하며, 시스템 설계 및 구현 단계에서 추적 가능해야 함.

#### **5. 검증 가능성 (Verifiability)**
- 요구사항은 검증 가능해야 하며, 테스트나 검토를 통해 확인할 수 있어야 함.

---

### **데이터 모델링이란?**

#### **정의**
- 현실 세계에서의 업무적인 프로세스를 물리적인 **데이터베이스**로 구체화시키기 위한 일련의 과정.

#### **데이터 모델링 과정**
1. **개념적 데이터 모델링 (Conceptual Data Modeling)**
   - 개념적 구조를 정의: 개별 대상 업무를 모델링.
   - 업무 프로세스를 개념적으로 표현.

2. **논리적 데이터 모델링 (Logical Data Modeling)**
   - 논리적 구조를 정의: 데이터 모델 설계.
   - 일반적으로 이야기하는 데이터 모델링 단계.

3. **물리적 데이터 모델링 (Physical Data Modeling)**
   - 물리적 데이터베이스 설계.
   - 논리적 모델을 실제 데이터베이스로 구현.

#### **데이터 모델링의 핵심**
- **업무 프로세스 → 개념적 모델 → 논리적 모델 → 물리적 데이터베이스**
- "일반적으로 이야기하는 데이터 모델링 = 논리적 모델링"

---

### **개념적 데이터 모델링**

- **비즈니스 요구사항을 반영한 고수준의 데이터 모델링**
  - 주로 ERD(Entity-Relationship Diagram)를 사용하여 표현.

- **독립적인 모델**
  - 데이터베이스의 물리적 구현에 독립적인 모델로, 사용자가 이해하기 쉬운 방식으로 데이터를 표현.

- **구조와 관계의 시각적 표현**
  - 데이터의 구조와 관계를 시각적으로 표현하여, 데이터베이스 설계의 기초를 마련하고, 시스템 요구사항을 이해 및 반영.

![image](https://github.com/user-attachments/assets/73e22e37-dc65-4f32-972b-987fd5b20cc6)

---

### **개념적 모델링 주요 구성 요소**

#### **1. 엔티티 (Entity)**
- 현실세계의 객체나 개념을 나타내며, 데이터베이스에 저장되는 주요 객체.
- **예:** 고객, 주문, 제품.

#### **2. 속성 (Attribute)**
- 엔티티의 특성을 나타내는 데이터 요소.
  - **예:** 고객의 이름, 주소, 전화번호.
- **속성의 종류:**
  - **단순 속성:** 더 이상 분해할 수 없는 속성 (예: 이름).
  - **복합 속성:** 여러 하위 속성으로 구성된 속성 (예: 주소).
  - **다중 값 속성:** 여러 값을 가질 수 있는 속성 (예: 전화번호).
  - **유도 속성:** 다른 속성의 값에서 계산된 속성 (예: 총 금액).

#### **3. 관계 (Relationship)**
- 엔티티 간의 연관성.
  - **예:** 고객이 주문을 한다, 주문이 제품을 포함한다.
- **관계의 종류:**
  - **일대일(1:1):** 한 엔티티가 다른 엔티티와 하나의 연관성 (예: 한 사람이 하나의 여권).
  - **일대다(1:N):** 한 엔티티가 다른 엔티티와 여러 연관성 (예: 한 고객이 여러 주문).
  - **다대다(M:N):** 여러 엔티티가 여러 다른 엔티티와 연관성 (예: 여러 학생이 여러 강의).
- **필수(Mandatory) 관계:**
  - 모든 엔티티가 관계에 참여해야 함 (예: 모든 주문은 반드시 1 고객에 의해 만들어져야 함).
- **선택(Optional) 관계:**
  - 일부 엔티티는 관계에 참여하지 않아도 됨 (예: 고객은 주문을 할 수도 있고 안 할 수도 있음).

#### **4. 식별자 (Identifier)**
- 엔티티를 고유하게 식별하는 하나 또는 그 이상의 속성.
  - **예:** 고객 엔티티의 고객 ID, 주문 엔티티의 주문 ID.

##### **식별자 종류**
1. **기본 식별자 (Primary Identifier):**
   - 각 인스턴스를 고유하게 식별하는 데 사용되는 주요 속성.
   - **예:** 고객 엔티티의 고객 ID, 주문 엔티티의 주문 ID.

2. **대체 식별자 (Alternate Identifier):**
   - 기본 식별자를 대신하여 각 인스턴스를 고유하게 식별할 수 있는 속성.
   - **예:** 이메일 주소가 고유할 경우 고객 엔티티 대체 식별자로 사용.

3. **복합 식별자 (Composite Identifier):**
   - 두 개 이상의 속성을 조합하여 각 인스턴스를 고유하게 식별하는 식별자.
   - **예:** 학번과 과목 ID를 조합하여 수강 기록을 고유하게 식별.

4. **자연 식별자 (Natural Identifier):**
   - 현실 세계에서 고유한 값을 갖는 속성을 식별자로 사용하는 경우.
   - **예:** 주민등록번호, ISBN.

5. **인조 식별자 (Surrogate Identifier):**
   - 시스템에 의해 생성된 고유 값을 식별자로 사용하는 경우.
   - **예:** 자동 증가 숫자, GUID.

---

### **개념적 데이터 모델링 단계**

#### **1. 요구사항 분석**
- 시스템의 요구사항을 수집하고 분석하여 데이터 모델링의 기초 자료를 마련.
- 이해관계자 인터뷰, 설문조사 등을 통해 데이터 요구사항을 수집.

#### **2. 엔티티 도출**
- 비즈니스 영역에서 필요한 주요 엔티티를 식별하고, 엔티티 후보 목록을 작성한 후 검토 및 확정.

#### **3. 속성 정의**
- 각 엔티티에 필요한 속성을 정의하며, 엔티티 속성 목록을 작성하고, 속성의 데이터 유형을 결정.

#### **4. 관계 설정**
- 엔티티 간의 관계를 정의하고, 관계의 유형(일대일, 일대다, 다대다)을 명확히 설정.
- 관계의 기수성(Cardinality) 및 선택성(Optionality)을 결정.

#### **5. ER 다이어그램 작성**
- 엔티티, 속성, 관계를 포함하는 ERD를 작성하여 주요 엔티티 및 관계를 시각적으로 표현.

#### **6. 검증 및 피드백**
- 작성된 모델을 검토하고 이해관계자들로부터 피드백을 받아 수정하면서, 모델의 일관성, 완전성, 정확성을 검토.

---

### **ER 다이어그램 기본 요소**

- **엔티티 (Entity):** 사각형으로 표현.
- **속성 (Attribute):** 타원형으로 표현.
- **관계 (Relationship):** 마름모로 표현.
- **관계선:** 선으로 표현.
- **식별자:** 밑줄로 표현.

![image](https://github.com/user-attachments/assets/fc02fefc-9604-455f-bc59-85350666009f)

---

### **개념적 모델링 장점**

#### **1. 이해 용이성**
- 기술적인 세부사항 없이 데이터 구조를 시각적으로 표현하여, 기술적 배경이 없는 사용자도 쉽게 이해할 수 있음.
- 엔티티, 속성, 관계 등을 다이어그램으로 표현하여 데이터 구조를 직관적으로 파악할 수 있음.

#### **2. 의사소통의 일원화**
- 개발자, 데이터베이스 설계자, 비즈니스 애널리스트, 사용자 등 다양한 이해관계자가 공통의 이해를 가질 수 있음.
- 비즈니스 요구사항을 명확히 모델링하여, 데이터베이스 설계에 정확하게 반영할 수 있음.

#### **3. 유연성 및 확장성**
- 데이터베이스 구현 전에 모델을 수정하거나 확장하기가 상대적으로 쉬움.
- 새로운 엔티티나 관계를 추가하거나 변경하기 용이하며, 기존 모델을 쉽게 확장할 수 있음.

#### **4. 데이터 품질 향상**
- 개념적 데이터 모델링을 통해 데이터의 정확성과 일관성을 높일 수 있음.
- 비즈니스 규칙과 제약 조건을 데이터 모델에 포함시켜, 데이터의 품질을 향상시킴.

#### **5. 재사용성**
- 동일하거나 유사한 데이터 구조가 필요한 다른 프로젝트나 시스템에서 개념적 데이터 모델을 재사용할 수 있음.

---

### **논리적 데이터 모델링**

#### **정의**
- 개념적 데이터 모델을 바탕으로, 데이터베이스 시스템의 논리적 구조를 정의하는 과정.

#### **구성 요소**
- 데이터베이스 시스템의 논리적 구조에는 **테이블, 열, 데이터 유형, 관계, 제약 조건** 등을 포함함.

#### **목적**
- 데이터의 정확성, 일관성, 무결성을 보장하는 논리적 구조를 설계하여, 데이터베이스 시스템의 효율적인 구현을 지원.

![image](https://github.com/user-attachments/assets/eea76b8d-8a5c-450b-b462-9f4265dc3979)

---

### **논리적 모델링 주요 구성 요소**

#### **1. 엔티티 (Entity)**
- **테이블로 변환**되며, 데이터베이스에서 저장되는 주요 객체를 나타냄.

#### **2. 속성 (Attribute)**
- **열로 변환**되며, 테이블 내에서 저장되는 데이터 요소를 나타냄.

#### **3. 관계 (Relationship)**
- **외래 키로 변환**되며, 테이블 간의 연관성을 정의.

#### **4. 식별자 (Identifier)**
- **기본 키로 변환**되며, 테이블 내에서 각 행을 식별하는 데 사용.

#### **5. 제약 조건 (Constraints)**
- 데이터의 정확성과 무결성을 유지하기 위한 규칙을 정의.

![image](https://github.com/user-attachments/assets/5f890422-4976-4a3a-84ce-8d0e4bcaed4f)

---

### **관계 표현 방식**

#### **1. 일대일 관계 (One-to-One, 1:1)**
- **정의**: 한 엔티티의 인스턴스가 다른 엔티티의 인스턴스와 하나씩만 연결되는 관계.
- **예**: 한 사람은 하나의 여권만 가질 수 있고, 하나의 여권은 한 사람만을 나타냄.

![image](https://github.com/user-attachments/assets/363817cc-c636-4127-99ff-994605674bfc)

#### **2. 일대다 관계 (One-to-Many, 1:N)**
- **정의**: 한 엔티티의 인스턴스가 다른 엔티티의 여러 인스턴스와 연결되는 관계.
- **예**: 한 고객은 여러 주문을 할 수 있지만, 하나의 주문은 하나의 고객에 속함.

![image](https://github.com/user-attachments/assets/6864e943-7a4f-4c42-9b50-4ba73c768e9e)

#### **3. 다대다 관계 (Many-to-Many, M:N)**
- **정의**: 여러 엔티티의 인스턴스가 서로 여러 개씩 연결되는 관계.
- **예**: 한 학생은 여러 강좌를 들을 수 있고, 한 강좌는 여러 학생이 들을 수 있음.
- **처리 방법**: 중간 테이블을 만들어 두 엔티티의 기본 키를 외래 키로 포함하여 표현.

![image](https://github.com/user-attachments/assets/3ecaf19b-6f9b-4e2b-8631-f7e40bde47f0)

---

### **논리적 데이터 모델링 단계**

#### **1. 개념적 모델 검토**
- 개념적 데이터 모델에서 도출된 엔티티, 속성, 관계를 검토.

#### **2. 엔티티를 테이블로 변환**
- 각 엔티티를 데이터베이스 테이블로 변환.

#### **3. 속성을 열로 변환**
- 각 속성을 테이블의 열로 변환하고 데이터 유형을 정의.

#### **4. 식별자 정의**
- 각 테이블의 기본 키를 정의하여 테이블 내 각 행을 고유하게 식별.

#### **5. 관계 설정**
- 테이블 간 외래 키를 설정하여 관계를 정의.

#### **6. 제약 조건 정의**
- 데이터 무결성을 유지하기 위해 제약 조건을 정의.
  - **예:** 고유성 제약, 무결성 제약, 참조 무결성 제약 등.

#### **7. 정규화 (Normalization)**
- 데이터를 중복 없이 효율적으로 저장하기 위해 정규화를 수행.
- 정규화는 데이터베이스 설계의 품질을 높이고, 데이터 일관성을 유지함.

---

### **논리적 모델링 장점**

#### **1. 데이터 정확성 및 무결성 보장**
- 제약 조건과 키를 통해 데이터의 정확성과 무결성을 유지할 수 있음.

#### **2. 효율적인 데이터 저장**
- 정규화를 통해 데이터 중복을 최소화하고, 저장 공간을 효율적으로 사용.

#### **3. 데이터베이스 구현의 기초 제공**
- 논리적 데이터 모델은 물리적 데이터 모델링과 데이터베이스 구현의 기초가 됨.

#### **4. 비즈니스 규칙 반영**
- 데이터베이스 설계에 비즈니스 규칙을 명확히 반영하여, 시스템 요구사항을 충족함.

---

### **정규화(Normalization) 필요성**

#### **1. 데이터 중복 감소**
- 데이터를 여러 테이블에 분산되어 저장됨으로써 중복되는 데이터를 최소화함.
- **효과**: 저장 공간 절약, 데이터 일관성 유지.

#### **2. 데이터 무결성 유지**
- 데이터의 일관성과 정확성 보장.
- 중복 데이터가 줄어들어 데이터의 수정, 삭제, 삽입 시 무결성이 유지됨.

#### **3. 데이터 이상(Anomaly) 방지**
- **추가 이상 (Insertion Anomaly)**: 데이터 삽입 시 불필요한 중복 데이터로 인해 데이터베이스를 피해 갈 수 있음.
- **변경 이상 (Update Anomaly)**: 데이터 갱신 시 모든 중복 데이터를 일관되게 수정할 수 있음.
- **삭제 이상 (Deletion Anomaly)**: 데이터 삭제 시 중요한 정보가 의도치 않게 손실되지 않음.

#### **4. 데이터베이스 설계의 효율성**
- 쿼리 성능을 향상시키고, 데이터 검색 및 조작을 더 효율적으로 수행할 수 있음.
- 각 테이블이 명확하게 정의되고, 특정한 역할을 수행하도록 함으로써 데이터베이스 설계를 쉽게 이해할 수 있게 됨.

#### **5. 데이터베이스 구조의 재사용성**
- 데이터베이스 구조가 명확하여, 유저들과 공유하기 쉽고, 새로운 요구사항에 따른 구조 변경도 쉽게 할 수 있음.

#### **6. 확장성 및 유연성**
- 새로운 데이터 요구사항이 발생할 때 설계 확장이 수월함.
- 새로운 엔터티나 속성을 추가하기가 용이함.

---

### **1차 정규형 (1NF)**

- **정의**: 테이블이 정규화의 첫 번째 단계에 부합하는 것을 의미하며, 다음과 같은 조건을 충족해야 함.

#### **1. 원자성 (Atomicity)**
- 모든 속성 값이 더 이상 분해할 수 없는 원자값이어야 함.

#### **2. 중복 행 제거**
- 모든 행이 고유해야 함.

#### **3. 컬럼 순서가 무의미**
- 컬럼의 순서가 데이터베이스 설계에 영향을 주지 않아야 함.

![image](https://github.com/user-attachments/assets/8d212243-82ee-45d1-9425-60de16907629)

---

### **2차 정규형 (2NF)**

- **정의**: 
  - 1차 정규형을 만족하고, 기본 키가 아닌 모든 속성이 기본 키의 모든 부분 집합에 완전히 종속되어야 함.

#### **조건**
1. **부분적 종속성 제거**:
   - 기본 키의 일부에만 종속적인 속성을 제거.

2. **복합 키의 의미**:
   - 2NF는 복합 키를 가진 테이블에서만 의미가 있음.

![image](https://github.com/user-attachments/assets/471a364f-4a3d-4164-86c9-47d0c8dff707)

---

### **3차 정규형 (3NF)**

- **정의**:
  - 2차 정규형을 만족하고, 비 기본 키 속성이 다른 비 기본 키 속성에 이행적 종속을 갖지 않아야 함.

#### **조건**
1. **이행적 종속성 제거**:
   - 비 기본 키 속성이 다른 비 기본 키 속성에 종속되지 않도록 함.

![image](https://github.com/user-attachments/assets/12585ff1-7214-436c-b252-914c02549dd1)

---

### **물리적 데이터 모델링**

- **정의**:
  - 논리적 데이터 모델을 기반으로 실제 데이터베이스 시스템에 맞게 물리적 구조를 설계하는 과정.

- **구성 요소**:
  - 물리적 구조에는 데이터베이스 테이블, 인덱스, 파티션, 저장소 매개변수 등을 포함함.

- **목적**:
  - 데이터베이스의 성능, 보안, 저장 효율성을 최적화하여 데이터의 효율적인 저장과 접근을 보장.

#### **데이터 모델링 과정**
1. **개념적 데이터 모델링**: 개별 대상 업무를 정의.
2. **논리적 데이터 모델링**: 논리적 구조를 정의.
3. **물리적 데이터 모델링**: 실제 데이터베이스 구현에 맞게 설계.

---

### **물리적 모델링 주요 구성 요소**

#### **1. 테이블 (Table)**
- 데이터를 저장하는 기본 단위로, 논리적 모델의 엔티티가 물리적 모델의 테이블로 변환됨.

#### **2. 열 (Column)**
- 테이블 내의 데이터 항목을 정의하며, 논리적 모델의 속성이 물리적 모델의 열로 변환됨.

#### **3. 데이터 유형 (Data Type)**
- 각 열의 데이터 형식을 정의함.
  - **예:** 정수형, 문자열형, 날짜형 등.

#### **4. 인덱스 (Index)**
- 데이터 검색을 빠르게 하기 위한 구조이며, 특정 열에 대해 인덱스를 생성하여 검색 성능을 향상시킴.

#### **5. 키 (Keys)**
- **기본 키 (Primary Key)**: 각 행을 고유하게 식별.
- **외래 키 (Foreign Key)**: 데이터의 무결성을 유지하기 위한 제약 조건을 정의.

#### **6. 뷰 (View)**
- 하나 이상의 테이블에서 데이터를 가져와 가상 테이블을 생성함.

#### **7. 저장소 매개변수 (Storage Parameters)**
- 테이블 및 인덱스의 저장소 특성을 정의함.
  - **예:** 테이블 스페이스, 블록 크기 등.

---

### **물리적 모델링 단계**

#### **1. 논리적 모델 검토**
- 논리적 데이터 모델에서 도출된 테이블, 열, 관계를 검토.

#### **2. 테이블 설계**
- 논리적 모델의 엔티티를 물리적 모델의 테이블로 변환하고, 각 테이블의 열과 데이터 유형을 정의.

#### **3. 키 및 제약 조건 정의**
- 각 테이블의 기본 키와 외래 키를 정의하고, 데이터 무결성을 유지하기 위한 제약 조건을 설정.

#### **4. 인덱스 설계**
- 검색 성능을 최적화하기 위해 인덱스를 설계.

#### **5. 뷰 설계**
- 필요한 경우, 데이터 접근을 용이하게 하기 위해 뷰를 생성.

#### **6. 저장소 매개변수 설정**
- 데이터베이스의 성능과 저장 효율성을 최적화하기 위해 저장소 매개변수를 설정.

#### **7. 보안 설정**
- 데이터 접근 권한 및 보안 규칙을 정의.

---

### **물리적 데이터 모델링 고려사항**

#### **1. 성능 최적화**
- 데이터베이스의 성능을 향상시키기 위해 인덱스, 파티션, 클러스터링 등을 고려.

#### **2. 저장 효율성**
- 저장 공간을 효율적으로 사용하기 위해 데이터 압축, 테이블 스페이스 관리 등을 고려.

#### **3. 보안**
- 데이터 접근 권한을 설정하고, 민감한 데이터를 보호하기 위한 보안 조치를 취함.

#### **4. 백업 및 복구**
- 데이터 손실에 대비해 백업 전략과 복구 절차를 마련.

#### **5. 확장성**
- 데이터베이스가 증가하는 데이터와 사용자 수를 처리할 수 있도록 확장 가능성을 고려.

---
### **역정규화 (Denormalization)**

#### **1. 역정규화란**
- 정규화된 데이터베이스를 의도적으로 비정규화하여 데이터 중복을 허용하는 방식으로, 데이터베이스 성능을 향상시키는 과정.
- 데이터 액세스 속도를 높이고, 복잡한 쿼리의 응답 시간을 줄이기 위해 데이터 중복과 저장 공간의 증가를 허용함.

#### **2. 역정규화 필요성**
- **쿼리 성능 최적화**: 읽기 작업이 많은 데이터베이스에서 쿼리 성능을 최적화하기 위해 사용됨.
- **복잡한 조인(Join) 감소**: 단일 테이블에서 데이터를 빠르게 조회할 수 있도록 설계.
- **데이터 구조 단순화**: 데이터 중복 저장하여 복잡한 쿼리 구조를 단순화함.

#### **3. 역정규화 장점**
- 데이터를 중복 저장함으로써 읽기 성능이 향상됨.
- 조인 연산을 줄이고, 데이터 조회 속도를 높임.
- 복잡한 쿼리를 단순화하여 유지보수와 관리가 용이함.

#### **4. 역정규화 단점**
- 데이터 중복으로 인해 저장 공간이 증가됨.
- 데이터 중복으로 인해 데이터 일관성을 유지하기 어려워질 수 있음.
- 데이터 중복으로 인한 추가, 수정, 삭제 작업이 복잡해지고, 데이터 일관성을 유지하기 위한 추가 작업이 필요함.

---

### **역정규화 기법**

#### **1. 중복 컬럼 추가**
- **정의**: 다른 테이블에 있는 속성을 중복 저장하여 조인 없이 조회할 수 있도록 함.
- **예**: 고객 테이블에 주문 합계를 저장하여, 주문 테이블과의 조인 없이 고객별 주문 합계를 조회할 수 있게 함.

#### **2. 중복 테이블 생성**
- **정의**: 데이터 조회 성능을 높이기 위해 자주 사용되는 데이터를 별도의 테이블에 중복 저장함.
- **예**: 복잡한 보고서를 생성할 때 관련 데이터를 하나의 테이블에 중복 저장하여 빠르게 조회할 수 있게 함.

#### **3. 집계 테이블 사용**
- **정의**: 자주 사용되는 집계 결과값을 미리 계산하여 저장하는 테이블을 생성함.
- **예**: 일별 매출 합계, 월별 매출 합계 등을 미리 계산하여 저장하는 테이블을 사용함.

#### **4. 파티셔닝 (Partitioning)**
- **정의**: 큰 테이블을 여러 작은 테이블로 분할하여 성능을 최적화함.
- **예**: 대규모 로그 데이터를 날짜별로 분할된 파티셔닝 테이블에 저장하여 성능을 향상시킴.

#### **5. 인덱스 추가**
- **정의**: 특정 열에 대한 인덱스를 추가하여 데이터 조회 성능을 높임.
- **예**: 자주 조회되는 열에 인덱스를 추가하여 검색 속도를 높임.

---

### **역정규화 예시**

![image](https://github.com/user-attachments/assets/6f7e6627-3718-4ab2-91dd-5f295058d24f)

![image](https://github.com/user-attachments/assets/15b31c9d-b7a5-4a0e-980c-c1829d356c26)

![image](https://github.com/user-attachments/assets/75c961aa-d941-42c7-91ff-bdbcd26d04ad)

---

### **테이블 디자인 시 고려할 사항**

#### **1. 데이터 유형 선정**
- 각 열의 데이터 유형을 신중하게 선택하여 저장 공간을 최적화하고 성능을 향상시킴.
- **주의**: 불필요하게 큰 데이터 유형을 사용하지 않도록 주의.

#### **2. 기본 키 설정**
- 기본 키는 각 행을 고유하게 식별할 수 있도록 설정해야 함.
- 기본 키는 가능한 한 단순하고 변경되지 않는 값을 사용함 (자동 증가열을 사용하면 편리).

#### **3. 외래 키 설정**
- 외래 키를 사용하여 테이블 간의 관계를 정의하고 참조 무결성을 유지함.
- 부모-자식 관계를 명확히 정의하여 데이터 무결성을 유지함.

#### **4. 인덱스 설계**
- 자주 조회되는 열에 대해 인덱스를 생성하여 검색 성능을 향상시킴.
- 인덱스는 검색 성능을 높이는 반면, 삽입과 갱신 성능에 영향을 줄 수 있으므로 적절하게 균형을 맞춤.
- 다중 열 인덱스는 여러 열을 동시에 검색할 때 유용함.

#### **5. 데이터 무결성 제약 조건**
- 필수 입력 항목은 NULL을 허용하지 않도록 설정함.
- 중복을 허용하지 않아야 하는 열에 대해 UNIQUE 제약 조건을 설정함.
- 값의 범위나 조건을 지정하기 위해 CHECK 제약 조건을 사용함.
- 특정 열에 대해 기본값을 설정하여 데이터 입력 오류를 줄임.

#### **6. 정규화와 역정규화**
- 데이터 중복을 최소화하고 데이터 무결성을 유지하기 위해 1차, 2차, 3차 정규형을 만족하도록 설계.
- 쿼리 성능을 최적화해야 할 경우 역정규화를 고려함 → 데이터 중복을 허용하여 읽기 성능을 향상시킬 수 있음.

#### **7. 파티셔닝 (Partitioning)**
- 대용량 테이블을 여러 작은 테이블로 분할하여 성능을 최적화함.
  - **예:** 날짜별로 파티셔닝하여 오래된 데이터를 별도로 관리.

#### **8. 데이터 보안 및 접근 제어**
- 각 테이블의 데이터 접근 권한을 적절하게 설정하여 데이터 보안을 유지함.
- 필요시 암호화하여 중요 데이터를 보호함.

#### **9. 저장소 매개변수 설정**
- 테이블 및 인덱스의 저장소 특성을 정의하여 저장 공간을 최적화함 (예: 테이블 스페이스, 블록 크기 설정).
- 데이터베이스 파일의 물리적 배치를 최적화하여 성능을 향상시킴.

---

### **추상화 계층 사용**

- **추상화 계층** = 뷰, 프로시저, 함수

#### **1. 응용 프로그램이 테이블에 직접 접근하면**
- 테이블 구조를 변경하고자 할 경우 응용 프로그램 수정이 필요.
- 이로 인해 테이블 구조 변경에 대한 부담이 가중됨.
- 제대로 모델링을 하고 싶어도 할 수 없는 상황이 됨.

#### **2. 추상화 계층을 사용하면**
- 응용 프로그램이 테이블을 직접 접근하지 않도록 함.
- 응용 프로그램이 테이블 대신 뷰, 프로시저, 함수를 사용하도록 함.
- 테이블 구조를 변경하고자 할 경우 뷰, 프로시저, 함수만 수정하면 됨.
- 프로시저의 경우 성능상의 이점을 연계함.
- 불필요한 데이터를 보이지 않게 함으로써 보안이 강화되는 효과가 있음.

---

### **비디오 숍 모델링 실습**

#### 회원제를 실시하는 비디오 상점의 요구사항
1. **회원 관리**: 회원에 대한 이름, 전화번호, 이메일, 우편번호, 주소, 등록일 등의 기본적인 정보를 관리해야 한다.
2. **비디오 관리**: 비디오에 대한 제목, 제작사, 주연배우, 감독, 개봉 일자, 출시일 등을 관리해야 한다.
3. **대여 여부 관리**: 비디오테이프에 대한 판수 여부와 대여 여부도 같이 관리해야 한다.
4. **장르 및 등급 관리**: 비디오테이프는 장르와 등급을 구분해서 관리해야 한다.
5. **대여 기간 관리**: 신 프로는 1일, 신 프로가 아닌 경우 2일이 기본 대여 일이다.
6. **연체 관리**: 반납이 연체되면 연체료를 받아야 하며, 비디오테이프가 파손되거나 분실된 경우 해당 회원이 변상해야 한다.
7. **포인트 제도 관리**: 대여 1회당 포인트 1점을 부여하고, 포인트가 10점이 되면 무료로 비디오 테이프 하나를 대여할 수 있다.
8. **운영 통계**: 숍 운영자는 일별, 월별 매출액과 대여 횟수를 확인할 수 있어야 한다.

![image](https://github.com/user-attachments/assets/76908b67-404d-47af-b1e7-8c99cc8cfa72)

---

### **인터넷 서점 모델링 실습**

#### **1. 서적 관리**
- 모든 서적은 대분류와 소분류에 의해 체계적으로 구분되어 관리되어야 한다.
- 인터넷을 통한 각 서적에 대한 충분한 정보가 제공되어야 한다.
- 제공되는 정보에는 서적에 대한 단종 여부, 재고 수량에 대한 정보가 포함되어야 한다.
- 출판사의 직거래를 통해 서적의 공급되고, 출판사에 대한 정보가 관리되어야 한다.

#### **2. 고객 관리**
- 고객은 회원 가입 후 주문을 할 수 있으며, 주문했을 때 마일리지가 적립된다.
- 고객이 관심 분야를 체크할 경우 관련된 신간 서적에 대한 정보를 이메일로 제공해야 한다.
- 이를 통해 고객이 자신이 관심이 있는 분야를 관리할 수 있어야 한다.

#### **3. 주문 관리**
1. 한 번 주문할 때 여러 권의 서적을 주문할 수 있다.
2. 결제 방법은 신용카드 결제, 온라인 결제, 마일리지 결제, 휴대폰 결제가 가능하다.
3. 사용 가능한 마일리지로만 온라인 결제가 가능하다.
4. 온라인 결제는 입금자와 입금 일자, 입금 금액, 은행명 등의 추가적인 정보가 관리되어야 한다.
5. 배송 정보:
   - 주문할 경우 배송지를 입력해야 하며, 고객의 기본 주소를 배송지로 선택할 수 있다.
   - 배송 후에 반품이나 환불을 요청할 수 있으므로 이에 정보가 관리되어야 한다.

![image](https://github.com/user-attachments/assets/3bd505f8-b60f-48d5-96f9-3d7a04cd0cf7)

---

### **영화 표 예매 사이트 모델링 실습**

#### **1. 영화 표**
- 체인점으로 전국 각지에 있는 극장에서는 여러 상영관을 보유하고 있으며, 각 상영관에서는 여러 영화를 상영한다.
- 각 상영관은 자체 상영 계획에 따라 상영이 이루어지며, 상영 계획과 상영관 좌석이 매칭되어 영화 표가 정의된다.

#### **2. 회원 관리**
- 회원과 비회원 모두 예매할 수 있으며, 비회원이면 기본적인 예매 관련 정보를 저장해야 한다.
- 회원이 영화 표를 예매할 때는 포인트를 적립한다.

#### **3. 영화 표 예매**
1. 온라인 또는 오프라인에서 예매할 수 있으며, 이에 대한 정보를 관리해야 한다.
2. 고객은 영화 표를 예매할 때 원하는 좌석을 지정할 수 있다.
3. 예매한 영화 표는 부분 취소와 전체 취소가 가능하다.
4. 예매를 취소한 경우에 환불해주어야 하며, 이에 대한 정보를 관리해야 한다.
5. 예매 결제 방법은 카드 결제와 계좌이체가 가능하다.

---

### **인터넷 경매 사이트 모델링 실습**

#### **1. 경매 물품**
- 경매 물품은 대분류와 소분류에 의해 체계적으로 관리되어야 한다.
- 인터넷을 통한 경매 물품들에 대한 정보가 고객들에게 자세히 제공되어야 한다.
- 경매 물품에 대한 정보는 회원들이 입력해서 등록되게 한다.
- 기본 등록비용 외에도, 등록 시 선택한 옵션에 따라 비용이 추가되게 한다.

#### **2. 회원 관리**
- 가입된 회원들이 경매 물품을 등록하며, 회원은 기업회원과 개인회원으로 구분한다.
- 회원의 사이트에서의 활동을 평가하여 신용도를 관리해야 한다.
- 신용도가 낮은 회원은 경매 물품 등록과 입찰 참여를 일정 기간 제한하여 건전한 거래가 유지될 수 있도록 한다.

#### **3. 경매 입찰**
1. 사이트에 등록된 물품의 입찰에 참여할 수 있으며, 회원 한 명이 같은 물품에 대해서 여러 번 입찰에 참여할 수 있다.
2. 낙찰된 회원은 낙찰금액을 결제해야 하며, 결제 방법은 신용카드, 온라인 결제, 휴대폰 결제 세 가지 방법이 있다.
3. 배송이 이루어진 후 반품이나 환불을 요구할 수 있으며, 반품에 대한 정보도 관리되어야 한다.
4. 완료된 거래에 관해서 경매 물품을 등록한 회원에게 주기적으로 송금이 이루어져야 하며, 그와 관련한 정보도 관리되어야 한다.

---

## **Chap 3. 데이터 집계**

***

---
### **집계 함수**

####  **정의**
- **집계 함수**는 테이블의 여러 행에 대한 계산을 수행하여 단일 값을 반환함.
- 주요 집계 함수: `SUM`, `AVG`, `MAX`, `MIN`, `COUNT`

####  **기능**
- **SUM**, **AVG**: 숫자에 대해서만 사용 가능.
- **MAX**, **MIN**, **COUNT**: 숫자, 문자, 날짜에 모두 사용 가능.

#### **사용 예시**
1. **최댓값, 최솟값 결정**:
   - 문자는 사전 순에 따라 최댓값, 최솟값 결정.
   - 날짜의 최솟값 → 가장 빠른(오래된) 날짜.
   - 날짜의 최댓값 → 가장 최근 날짜.
2. **행 수 구하기**:
   - `COUNT(*)`를 사용하여 행 수를 구함.

```sql
SELECT COUNT(*) AS emp_count
FROM employee
WHERE retire_date IS NULL;
```

---

### **전체 집계**

#### **정의**
- `WHERE` 절의 조건을 만족하는 모든 행(조건이 없으면 전체 행)에 대해 집계 계산을 수행.
- 예: 전체 판매 수량, 오늘 하루 전체 판매 금액, 서울 지역 전체 고객 수 계산 등.

#### **특징**
- **출력 결과는 하나의 행**
- `SUM`, `AVG`, `MIN`, `MAX`, `COUNT` 등을 사용해 계산 가능.

**시스템 부서 직원들의 급여 합 집계**
```sql
SELECT SUM(salary) AS tot_salary
FROM employee
WHERE dept_id = 'SYS';
```
**전 직원 급여 합, 급여 평균 집계**
```sql
SELECT SUM(salary) AS tot_salary, AVG(salary) AS avg_salary
FROM employee
WHERE retire_date IS NULL;
```

---

### **집계 함수와 NULL 값**

#### **특징**
- 집계 함수는 **NULL 값을 무시함** (없는 값으로 간주)
- **SUM**: NULL 값을 제외한 나머지 값의 합.
- **AVG**: NULL 값을 제외한 나머지 값의 합을 NULL 값을 제외한 값의 개수로 나눔.
- **MIN, MAX**: NULL 값을 제외한 값 중에서 가장 작은/큰 값을 반환.
- **COUNT**: NULL 값을 제외한 값의 개수를 반환. (`COUNT(*)`는 NULL을 무시하지 않음.)

#### **SQL 예제**
**NULL 값을 무시하는 예제**
```sql
SELECT SUM(salary) / COUNT(*) AS avg_salary
FROM employee
WHERE retire_date IS NULL;
```
**NULL을 0으로 대체하는 예제**
```sql
SELECT AVG(IFNULL(salary, 0)) AS avg_salary
FROM employee
WHERE retire_date IS NULL;
```

---

### **그룹별 집계**

```sql
SELECT 집계 기준 열, 집계함수1, 집계함수2, ...
FROM 테이블
WHERE 조건
GROUP BY 집계 기준 열
ORDER BY 정렬 기준 열 ASC | DESC;
```

#### **정의**
- GROUP BY를 사용해 **그룹별 집계**를 수행.
- 예: 지역별 구매 수량 합계, 남녀별 점수 평균, 영업점별 판매 수량과 금액 집계 등.

#### **특징**
- 집계 기준 열을 기준으로 그룹핑.
- GROUP BY 후, 각 그룹에 대해 집계 함수가 적용됨.
- 정렬이 필요할 경우 `ORDER BY`를 사용.

#### **SQL 예제**
**부서별 직원 수 집계**
```sql
SELECT dept_id, COUNT(*) AS emp_count
FROM employee
WHERE retire_date IS NULL
GROUP BY dept_id;
```

---

### **그룹별 집계와 HAVING 절**

```sql
SELECT 집계 기준 열, 집계함수1, 집계함수2, ...
FROM 테이블
WHERE 조건
GROUP BY 집계 기준 열
HAVING 조건
ORDER BY 정렬 기준 열 ASC | DESC;
```

#### **정의**
- **WHERE** 절: **그룹핑 전에** 집계 대상 행을 필터링.
- **HAVING** 절: **그룹핑 후** 집계 결과에 대해 조건을 필터링.

#### **WHERE 절과 HAVING 절의 차이**
- **WHERE**: 개별 행에 조건을 걸어 그룹핑 대상 행을 제한.
- **HAVING**: 그룹핑 후, 집계 결과에 조건을 걸어 제한.

#### **SQL 예제**
**부서별 직원 수가 3명 이상인 부서만 조회**
```sql
SELECT dept_id, COUNT(*) AS emp_count
FROM employee
WHERE retire_date IS NULL
GROUP BY dept_id
HAVING COUNT(*) >= 3
ORDER BY emp_count DESC;
```

---

### **집계 함수와 NULL 값**

#### **특징**
- 집계 함수는 **NULL 값을 무시함** (없는 값으로 간주)
- **SUM**: NULL 값을 제외한 나머지 값의 합.
- **AVG**: NULL 값을 제외한 나머지 값의 합을 NULL 값을 제외한 값의 개수로 나눔.
- **MIN, MAX**: NULL 값을 제외한 값 중에서 가장 작은/큰 값을 반환.
- **COUNT**: NULL 값을 제외한 값의 개수를 반환. (`COUNT(*)`는 NULL을 무시하지 않음.)

#### **SQL 예제**
**NULL 값을 무시하는 예제**
```sql
SELECT SUM(salary) / COUNT(*) AS avg_salary
FROM employee
WHERE retire_date IS NULL;
```
**NULL을 0으로 대체하는 예제**
```sql
SELECT AVG(IFNULL(salary, 0)) AS avg_salary
FROM employee
WHERE retire_date IS NULL;
```

---

### **그룹별 집계**

```sql
SELECT 집계 기준 열, 집계함수1, 집계함수2, ...
FROM 테이블
WHERE 조건
GROUP BY 집계 기준 열
ORDER BY 정렬 기준 열 ASC | DESC;
```

#### **정의**
- GROUP BY를 사용해 **그룹별 집계**를 수행.
- 예: 지역별 구매 수량 합계, 남녀별 점수 평균, 영업점별 판매 수량과 금액 집계 등.

#### **특징**
- 집계 기준 열을 기준으로 그룹핑.
- GROUP BY 후, 각 그룹에 대해 집계 함수가 적용됨.
- 정렬이 필요할 경우 `ORDER BY`를 사용.

#### **SQL 예제**
**부서별 직원 수 집계**
```sql
SELECT dept_id, COUNT(*) AS emp_count
FROM employee
WHERE retire_date IS NULL
GROUP BY dept_id;
```

---

### **그룹별 집계와 HAVING 절**

```sql
SELECT 공통 기준 열, 집계함수1, 집계함수2, ...
FROM 테이블
WHERE 조건
GROUP BY 공통 기준 열
HAVING 조건
ORDER BY 정리 기준 열 ASC | DESC;
```

#### **정의**
- **WHERE** 제: **그룹핑 전에** 집계 대상 행을 필터링 하는 구문.
- **HAVING** 제: **그룹핑 후** 집계 결과에 대해 조건을 필터링 하는 구문.

#### **WHERE 제와 HAVING 제의 차이**
- **WHERE**: 개별 행에 조건을 걸어 그룹핑 대상 행을 제한합니다.
- **HAVING**: 그룹핑 후, 집계 결과에 조건을 걸어 제한합니다.

#### **비교**
| 구분         | WHERE 절                         | HAVING 절                         |
|--------------|---------------------------------|---------------------------------|
| **작동 시점**| 그룹핑 이전에 실행             | 그룹핑 이후에 실행               |
| **조건 대상**| 테이블의 개별 행에 대한 조건    | 그룹핑된 집계 결과에 대한 조건  |
| **사용 위치**| GROUP BY 이전                   | GROUP BY 이후                    |


```sql
SELECT dept_id, COUNT(*) AS emp_count
FROM employee
WHERE retire_date IS NULL  -- 퇴직한 직원은 제외
GROUP BY dept_id           -- 부서별로 그룹핑
HAVING COUNT(*) >= 3       -- 직원 수가 3명 이상인 부서만 조회
ORDER BY emp_count DESC;   -- 직원 수 기준 내림차순 정렬
```

---

### **Chap 4. 순위 함수**

***

---
### **순위 함수 소개**
#### **순위 함수란?**
- 특정 열을 기준으로 데이터를 정리하고 이 결과에 순위나 번호를 부여함.
- `RANK()`, `DENSE_RANK()`, `ROW_NUMBER()`, `NTILE()` 함수 모두 `OVER` 제를 필요로 함.
- `OVER` 제 안에 정리 기준과 분합 기준을 지정하며 분합 기준은 사직할 수 있음.

```sql
SELECT emp_name, emp_id, gender, dept_id, hire_date, salary,
       RANK() OVER(PARTITION BY gender ORDER BY salary DESC) AS rnk
FROM employee
WHERE retire_date IS NULL;
```

#### **주요 순위 함수**
1. **RANK()**: 순위를 부여하며 동일 순위가 있을 경우 다음 순위를 건너뛰.
2. **DENSE_RANK()**: 동일 순위가 있어도 다음 순위를 건너뛰지 않고 열속적으로 부여.
3. **ROW_NUMBER()**: 동일 값과 사괴여 고유한 행 번호를 부여.
4. **NTILE(n)**: 데이터를 `n`개의 그룹으로 나누르며 각 그룹만큼 번호를 부여.

| 함수    | 결과        |
|----------|------------|
| RANK()   | 1, 2, 2, 4, 5 |
| DENSE_RANK() | 1, 2, 2, 3, 4 |
| ROW_NUMBER() | 1, 2, 3, 4, 5 |
| NTILE(2) | 1, 1, 2, 2, 2 |

#### 참고: 네 함수 모든 표시되는 결과만 다른 것이다는 점을 가지며 사용 방법은 같을 필요가 없고 하나의 사용 방법만 잘 이해하면 된다.

---

### **RANK 함수**

- 정리된 데이터에서 현재 행의 **순위**를 반환.
- 동일한 값이 두 개 이상 있을 경우 같은 순위를 부여하고, 다음 순위는 중복된 순위 개수만큼 건너뛰어 부여.
- `OVER` 제 안에 `ORDER BY` 문으로 순위를 정해기 위해 정리 기준을 지정.
- 최종 출력 결과에 새로운 정리 기준을 적용하고 싶다면 **쿠리문 마지막에 `ORDER BY` 문 추가**.

```sql
SELECT emp_name, emp_id, gender, dept_id, hire_date, salary,
       RANK() OVER(ORDER BY salary DESC) AS rnk
FROM employee
WHERE retire_date IS NULL AND salary IS NOT NULL;
```

---

### **DENSE_RANK 함수**

- `RANK()` 함수와 사용 방법이 같으나, **표시되는 순위에 누랍된 숫자가 없음**.
- 같은 순위가 있어도 이어지는 순위는 건너뛰지 않고 부여함.

```sql
SELECT emp_name, emp_id, gender, dept_id, hire_date, salary,
       DENSE_RANK() OVER(ORDER BY salary DESC) AS rnk
FROM employee
WHERE retire_date IS NULL AND salary IS NOT NULL;
```

---

### **ROW_NUMBER 함수**

- 정리된 결과에 **일러운 번호를 부여**.
- `PARTITION BY`를 사직하지 않은 경우 한 같은 번호는 부여되지 않음.

```sql
SELECT ROW_NUMBER() OVER(ORDER BY emp_name ASC) AS num,
       emp_name, emp_id, gender, dept_id, hire_date, salary
FROM employee
WHERE retire_date IS NULL AND salary IS NOT NULL;
```

---

### **NTILE 함수**

- 데이터를 **몇 개의 그룹으로 나누** 각 그룹만큼 번호를 부여.
- 그룹의 개수를 지정해야 하니까 다른 함수와는 다르게 `NTILE(n)` 형식으로 사용.

```sql
SELECT emp_name, emp_id, gender, dept_id, hire_date, salary,
       NTILE(3) OVER(ORDER BY salary DESC) AS grp
FROM employee
WHERE retire_date IS NULL AND salary IS NOT NULL;
```

---

## **Chap 5. 데이터 변경**

---

### **DML문**

- **DML**: Data Manipulation Language
- 데이터 조작 언어 = 데이터를 변경하는 쿼리문
- **INSERT**, **UPDATE**, **DELETE**, **SELECT** 문이 DML문에 포함됨
- 잘못 변경된 데이터의 복구가 어려울 수 있으므로 **주의 필요**
- **SELECT 문으로 사전 확인**: 변경 대상 데이터를 미리 확인하는 습관이 필요함
- **정확한 조건 설정**: UPDATE 및 DELETE 문에서는 조건을 명확히 지정해야 함
- 실수 방지를 위해 DML 문을 `/* 주석 */` 처리하여 수행되지 않도록 방지하는 것도 방법임

---

### **INSERT 문**

```sql
INSERT INTO 테이블 (열1, 열2, ...)
VALUES (값1, 값2, ...);
```

- **열 이름을 지정한 예시**
```sql
INSERT INTO department(dept_id, dept_name, unit_id, start_date)
VALUES('PRD', '상품', 'A', '2022-10-01');
```

- **열 이름을 생략한 예시**
```sql
INSERT INTO department
VALUES('DBA', 'DB관리', 'A', '2022-10-01');
```
- 열 이름 생략은 **모든 열이 원래 순서로 나열된 경우에만** 가능
- **가독성을 위해 열 이름을 생략하지 않는 것을 권장**

- **여러 행을 동시에 추가**
```sql
INSERT INTO 테이블 (열1, 열2, ...)
VALUES (값1, 값2, ...), 
       (값1, 값2, ...), 
       ...;
```
```sql
INSERT INTO department
VALUES ('PRD', '상품', 'A', '2022-10-01'),
       ('DBA', 'DB관리', 'A', '2022-10-01');
```

- **SELECT 문을 활용한 INSERT**
- SELECT 문 수행 결과를 테이블에 INSERT할 수 있음
- SELECT 문 결과의 열 개수와 INSERT 대상 테이블의 열 개수가 일치해야 함
- 추가될 값과 입력받을 열의 데이터 형식이 서로 **호환되어야 함**
```sql
INSERT INTO 테이블 (열1, 열2, ...)
SELECT 열1, 열2, ...
FROM 테이블
WHERE 조건;
```
```sql
INSERT INTO retired_employee
SELECT * FROM employee WHERE retired_date IS NOT NULL;
```

---

### **UPDATE 문**

```sql
UPDATE 테이블
SET 열1 = 값1, 열2 = 값2, ...
WHERE 조건;
```

- **행의 값 변경**
  - **SET 절**: 변경할 열과 새로운 값을 지정
  - **WHERE 절**: 조건을 설정하여 변경할 행을 선택
  - **WHERE 절을 생략하면 모든 행이 업데이트되므로 주의 필요**

- **예시**
```sql
UPDATE employee
SET phone = '010-1239-1239'
WHERE emp_id = 'S0001';
```
> emp_id가 'S0001'인 행의 phone 값을 '010-1239-1239'로 변경

---

### **DELETE 문**

```sql
DELETE FROM 테이블
WHERE 조건;
```

- **조건에 맞는 행 삭제**
  - WHERE 절을 사용해 특정 조건을 만족하는 행 삭제
  - **WHERE 절을 생략하면 테이블의 모든 행이 삭제됨**

- **예시**
```sql
DELETE FROM vacation
WHERE end_date <= '2017-12-31';
```
> end_date가 '2017-12-31' 이전인 모든 행 삭제

- **테이블의 모든 데이터 삭제**
  - DELETE 또는 TRUNCATE를 사용 가능
  - **TRUNCATE**는 삭제 속도가 더 빠르며, **롤백 불가능**

- **DELETE 문 예시**
```sql
DELETE FROM vacation;
```

- **TRUNCATE 문 예시**
```sql
TRUNCATE TABLE vacation;
```
> TRUNCATE는 전체 데이터를 삭제하는 데 최적화되어 있으며, 롤백이 불가능하므로 주의해야 함

---

## **Chap 6. 다중 테이블 조회**

---

### **JOIN의 필요성**
- 관계형 데이터베이스는 여러 테이블로 데이터가 나뉘어 존재하는 형태
- 대부분의 테이블들이 **Primary Key(PK)**, **Foreign Key(FK)**로 관계를 설정해 연결된 상태
- 하나의 테이블에서만 데이터를 조회하는 쿼리는 한계에 부딪히게 됨
- 결국 의미 있는 결과를 얻기 위해서 여러 테이블에서 데이터를 조회해야 함
- **JOIN문**과 **하위 쿼리**를 사용해 여러 테이블을 연결해 조회할 수 있음

![image](https://github.com/user-attachments/assets/e1477cba-4571-476c-8035-043ffcdf1d0d)

---

### **ERD를 참고해야 하는 이유**
- **관계 이해**
  - ERD는 테이블 간의 관계를 시각적으로 표현함
  - 어떤 테이블이 어떻게 연결되어 있는지를 쉽게 파악할 수 있어, 조인할 테이블을 식별하는 데 도움이 됨
- **키 확인**
  - ERD를 통해 각 테이블의 **기본 키(PK)**와 **외래 키(FK)**를 확인할 수 있음
  - 이는 조인 조건을 설정하는 데 필수적인 정보임
- **데이터 흐름 파악**
  - ERD는 데이터 흐름과 의존성을 명확히 보여줌
  - 이를 통해 올바른 순서와 방식으로 테이블을 조인할 수 있음
- **복잡성 감소**
  - ERD를 참조하면 복잡한 쿼리 구조를 시각적으로 이해할 수 있음
  - 조인문을 작성하는 과정에서 발생할 수 있는 오류를 줄일 수 있음

---

### **hrd2024 데이터베이스 ERD**
![image](https://github.com/user-attachments/assets/a73eecd6-9167-48e5-933c-6a7a0284b6b6)

---

### **JOIN 문 작성 3단계**
- **1단계**: 테이블 연결
```sql
SELECT emp_id, emp_name, employee.dept_id, department.dept_name, phone, email
FROM employee
JOIN department ON employee.dept_id = department.dept_id;
```

- **2단계**: 테이블 별칭 지정 → 쿼리문이 간결해짐
```sql
SELECT emp_id, emp_name, e.dept_id, d.dept_name, phone, email
FROM employee AS e
JOIN department AS d ON e.dept_id = d.dept_id;
```

- **3단계**: 테이블 별칭 활용 → 쿼리문 이해에 도움을 줌
```sql
SELECT e.emp_id, e.emp_name, e.dept_id, d.dept_name, e.phone, e.email
FROM employee AS e
JOIN department AS d ON e.dept_id = d.dept_id;
```

---

### **INNER JOIN**
- 가장 일반적인 **JOIN** 형태
- 양쪽 테이블에서 **비교되는 값이 일치하는 행만 가져옴**
- 일반적으로 **PK**와 **FK**가 **ON 절**에서 서로 비교됨

![image](https://github.com/user-attachments/assets/1ef0d014-a91b-42a5-8849-01cd861e1551)

---

### **OUTER JOIN**
- **비교되는 값이 일치하지 않는 행도 기준 테이블에서 가져옴**
- **LEFT OUTER JOIN**, **RIGHT OUTER JOIN**, **FULL OUTER JOIN**으로 구분
- 단, **MySQL은 FULL OUTER JOIN이 없음**

![image](https://github.com/user-attachments/assets/6f9bef50-2841-49b7-8bee-220012fde5a3)

---

### **CROSS JOIN**
- **일반적인 비즈니스 응용프로그램에서 사용되지 않음**
- **ON 절이 없어 모든 경우의 수 만큼 결과 행을 얻음**
- 대량의 테스트 데이터를 만드는 목적으로 많이 사용됨

![image](https://github.com/user-attachments/assets/88165e8d-69a5-474f-ac5b-ab08918c3f51)

---

### **JOIN 사용 예**
- **INNER JOIN**: 직원 정보 조회 시 부서 이름 포함
```sql
SELECT e.emp_id, e.emp_name, e.dept_id, d.dept_name, e.phone
FROM employee AS e
INNER JOIN department AS d ON e.dept_id = d.dept_id
WHERE e.hire_date BETWEEN '2020-01-01' AND '2020-12-31' AND e.retire_date IS NULL;
```

- **OUTER JOIN**: 모든 부서 정보 조회 시 본부 이름 포함
```sql
SELECT d.dept_id, d.dept_name, d.unit_id, u.unit_name
FROM department AS d
LEFT OUTER JOIN unit AS u ON d.unit_id = u.unit_id;
```

---

### **여러 테이블 조인**
- 테이블 간의 관계를 알고 작성하면 쉽게 작성할 수 있음
```sql
SELECT e.emp_id, e.emp_name, d.dept_name, u.unit_name, v.begin_date, v.duration
FROM employee AS e
INNER JOIN department AS d ON e.dept_id = d.dept_id
LEFT OUTER JOIN unit AS u ON d.unit_id = u.unit_id
INNER JOIN vacation AS v ON e.emp_id = v.emp_id
WHERE v.begin_date BETWEEN '2021-01-01' AND '2021-03-31'
ORDER BY e.emp_id ASC;
```

---

### **하위 쿼리(Sub-query)**
- **괄호 안에 또 다른 쿼리문이 있는 쿼리문**
- 대부분 **JOIN 문으로 작성해서 같은 결과를 얻을 수 있음**
- **JOIN 문보다 작성하기가 쉬움**
```sql
SELECT emp_id, emp_name, salary
FROM employee
WHERE salary = (SELECT MAX(salary) FROM employee);
```

- 일반적인 하위 쿼리에 비해 **상관 하위 쿼리**를 이해하기가 다소 어려움
```sql
SELECT emp_id, emp_name, salary
FROM employee AS e
WHERE EXISTS (SELECT * FROM vacation WHERE emp_id = e.emp_id);
```

---

### **하위 쿼리 사용 예**
- **가장 먼저 입사한 직원 정보 조회**
```sql
SELECT emp_id, emp_name, dept_id, phone, email, salary
FROM employee
WHERE hire_date = (SELECT MIN(hire_date) FROM employee);
```

- **휴가를 간 적이 있는 정보시스템 직원 정보 조회**
```sql
SELECT emp_id, emp_name, dept_id, phone, email
FROM employee
WHERE dept_id = 'SYS' AND emp_id IN (SELECT emp_id FROM vacation);
```

- **휴가를 간 적이 없는 정보시스템 직원 정보 조회**
```sql
SELECT emp_id, emp_name, dept_id, phone, email
FROM employee
WHERE dept_id = 'SYS' AND emp_id NOT IN (SELECT emp_id FROM vacation);
```

---

## **Chap 7. 뷰(Views)**

---

### **뷰 만들기**
- 뷰는 쿼리문을 가지고 서버에 존재하는 개체로, **뷰를 조회하면 뷰가 가지고 있는 쿼리가 실행되어 결과 반환**
- **SELECT 문 작성**: 뷰가 보여줄 데이터를 정의하는 SELECT 문 작성이 99.9%의 작업
- **CREATE VIEW 문 작성**: SELECT 문을 기반으로 뷰 생성
```sql
CREATE VIEW employee_info
AS
SELECT e.emp_name, e.emp_id, e.gender, e.dept_id, d.dept_name, e.hire_date
FROM employee AS e
INNER JOIN department AS d ON e.dept_id = d.dept_id
WHERE e.retire_date IS NULL;
```
```sql
SELECT * FROM employee_info;
```
- **테이블 구조 및 쿼리의 복잡성을 숨길 수 있음** → 사용자 관점의 데이터 제공
- **민감한 데이터 접근 제한**: 뷰가 보여주는 데이터만 접근 가능, **보안 강화**

---

### **뷰 변경과 제거**
- **ALTER VIEW**: 뷰 변경 방법 1
```sql
ALTER VIEW employee_info
AS
SELECT e.emp_name, e.emp_id, e.gender, d.dept_name, e.hire_date, e.email, e.phone
FROM employee AS e -- 생략
```

- **CREATE OR REPLACE VIEW**: 뷰 변경 방법 2 (**MS SQL은 CREATE OR ALTER 사용**)
```sql
CREATE OR REPLACE VIEW employee_info
AS
SELECT e.emp_name, e.emp_id, e.gender, d.dept_name, e.hire_date, e.email, e.phone
FROM employee AS e -- 생략
```

- **DROP VIEW**: 불필요한 뷰 제거
```sql
DROP VIEW employee_info;
```

---

### **열 별칭 지정**
- **방법 1**: AS를 사용해 별칭 지정
```sql
CREATE VIEW employee_info 
AS
SELECT e.emp_name AS 이름, e.emp_id AS 사번, e.gender AS 성별, e.dept_id AS 부서코드, d.dept_name AS 부서이름, e.hire_date AS 입사일
FROM employee AS e
INNER JOIN department AS d ON e.dept_id = d.dept_id
WHERE e.retire_date IS NULL;
```

- **방법 2**: 뷰 선언 부분에서 별칭 지정
```sql
CREATE VIEW employee_info(이름, 사번, 성별, 부서코드, 부서이름, 입사일) 
AS
SELECT e.emp_name, e.emp_id, e.gender, e.dept_id, d.dept_name, e.hire_date
FROM employee AS e
INNER JOIN department AS d ON e.dept_id = d.dept_id
WHERE e.retire_date IS NULL;
```

---

### **WITH CHECK OPTION**
- **뷰(View) 조건을 벗어나지 않도록 데이터 변경 제한**
- **뷰 생성 시 특정 조건을 부여** → 데이터 변경이 조건을 위반하지 않도록 제한

#### **뷰 생성**
- 특정 조건에 맞는 데이터를 보여주는 뷰 생성
- `WITH CHECK OPTION`을 추가하여 뷰를 통한 데이터 변경이 조건을 위반하지 않도록 제한
```sql
CREATE OR REPLACE VIEW high_salary AS
SELECT e.emp_name, e.emp_id, d.dept_id, e.gender, e.hire_date, e.salary
FROM employee AS e
INNER JOIN department AS d ON e.dept_id = d.dept_id
WHERE e.salary >= 8000
WITH CHECK OPTION;
```

#### **데이터 변경 시도 및 제한**
- **WITH CHECK OPTION 적용 후 데이터 변경 시도**
- 조건을 위반하는 경우 오류 발생
```sql
UPDATE high_salary
SET salary = 7000
WHERE emp_id = 'S0002';
/* 결과:
Error Code: 1369. CHECK OPTION failed 'hrdb2019.high_salary' 0.016 sec
*/
```

---